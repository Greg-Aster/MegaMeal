---
// src/components/timeline/StarMapView.astro
import type { TimelineEvent } from '../../../services/TimelineService.client';

export interface Props {
  id?: string;
  events: TimelineEvent[];
  useEraColors?: boolean;
  skyboxImageUrl?: string;
}

const {
  id = "starmap-view",
  events,
  useEraColors = false,
  skyboxImageUrl = "/assets/hdri/sky3.png",
} = Astro.props;

const mapId = `${id}-three-container`;
const floatingCardId = `${id}-floating-card`;

// Prepare events for starmap
const starmapEventsJson = JSON.stringify(events.map(e => ({
  slug: e.slug,
  title: e.title,
  year: e.year,
  description: e.description || "No description available.",
  era: e.era,
  isKeyEvent: e.isKeyEvent || false,
})));
---

<div id={mapId} class="starmap-three-container" style="width: 100%; height: 100%; overflow: hidden; background-color: #000510; position: relative;">
  <p class="starmap-loading-message" style="color: white; text-align: center; padding-top: 20%; font-family: sans-serif;">Loading 3D Starmap...</p>
  
  <!-- Floating card for timeline events -->
  <div id={floatingCardId} class="starmap-floating-card" style="position: absolute; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 200;">
    <!-- Card content will be dynamically inserted here -->
  </div>
</div>

<script define:vars={{
  mapId,
  floatingCardId,
  starmapEventsJson,
  skyboxImageUrl,
  useEraColors,
}}>
  // Star appearance helpers - from StarNode.astro
  const eraColorMap = {
    'ancient-epoch': '#3b82f6',
    'awakening-era': '#8b5cf6',
    'golden-age': '#6366f1',
    'conflict-epoch': '#ec4899',
    'singularity-conflict': '#ef4444',
    'transcendent-age': '#14b8a6',
    'final-epoch': '#22c55e',
    'unknown': '#6366f1'
  };

  const colorSpectrum = [
    '#ef4444', '#f43f5e', '#f97316', '#f59e0b', '#eab308', '#facc15',
    '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6',
    '#6366f1', '#8b5cf6', '#a855f7', '#d946ef', '#ec4899',
  ];

  const starTypes = ['point', 'classic', 'sparkle', 'refraction', 'halo', 'subtle'];

  function hashCode(str) {
    if (!str) return 0;
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash);
  }

  function getStarColor(id, currentEra, shouldUseEraColors) {
    if (shouldUseEraColors && currentEra && eraColorMap[currentEra]) {
      return eraColorMap[currentEra];
    }
    const hash = hashCode(id);
    return colorSpectrum[hash % colorSpectrum.length];
  }

  function getStarType(id, keyEvent) {
    const hash = hashCode(id);
    if (keyEvent) {
      return ['classic', 'sparkle', 'refraction', 'halo'][hash % 4];
    }
    return starTypes[hash % starTypes.length];
  }

  function getSizeFactor(keyEvent) {
    return keyEvent ? 1.2 : 0.85 + (Math.random() * 0.3);
  }

  function getAnimationDuration(id) {
    const hash = hashCode(id);
    return 4 + (hash % 5);
  }

  // Starmap state
  let THREE, OrbitControls;
  let scene, camera, renderer, controls, gridGroup, starsGroup;
  let initialized = false;
  let currentEvents = JSON.parse(starmapEventsJson);
  let selectedEvent = null;
  let floatingCard = null;
  let raycaster, mouse;
  let starSprites = new Map(); // Map of slug -> sprite for easy lookup
  let orbitalRings = new Map(); // Map of slug -> orbital ring objects
  let animationStartTime = Date.now();

  // Create orbital ring texture
  function createOrbitalRingTexture(color, ringType = 'base', size = 256) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    const center = size / 2;
    const outerRadius = size * 0.45;
    const innerRadius = size * 0.35;
    
    // Clear canvas
    ctx.clearRect(0, 0, size, size);
    
    // Create ring gradient
    const gradient = ctx.createRadialGradient(center, center, innerRadius, center, center, outerRadius);
    
    if (ringType === 'selected') {
      gradient.addColorStop(0, color + '00');
      gradient.addColorStop(0.3, color + '80');
      gradient.addColorStop(0.7, color + 'CC');
      gradient.addColorStop(1, color + '00');
    } else if (ringType === 'init') {
      gradient.addColorStop(0, color + '00');
      gradient.addColorStop(0.2, color + 'AA');
      gradient.addColorStop(0.8, color + 'DD');
      gradient.addColorStop(1, color + '00');
    } else { // base
      gradient.addColorStop(0, color + '00');
      gradient.addColorStop(0.4, color + '20');
      gradient.addColorStop(0.6, color + '40');
      gradient.addColorStop(1, color + '00');
    }
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(center, center, outerRadius, 0, Math.PI * 2);
    ctx.arc(center, center, innerRadius, 0, Math.PI * 2, true); // Cut out center
    ctx.fill();
    
    return new THREE.CanvasTexture(canvas);
  }

  // Create orbital rings for a star
  function createOrbitalRingsForStar(starSprite, eventData) {
    const rings = [];
    const color = eventData.mainColor;
    
    // Base orbital ring (always present, very subtle)
    const baseRingTexture = createOrbitalRingTexture(color, 'base');
    const baseRingMaterial = new THREE.SpriteMaterial({ 
      map: baseRingTexture, 
      transparent: true,
      opacity: 0.1,
      blending: THREE.AdditiveBlending
    });
    const baseRing = new THREE.Sprite(baseRingMaterial);
    baseRing.position.copy(starSprite.position);
    baseRing.scale.setScalar(starSprite.scale.x * 1.5);
    baseRing.userData = {
      type: 'base',
      parentStar: eventData.slug,
      animationPhase: Math.random() * Math.PI * 2,
      rotationSpeed: 0.0005
    };
    rings.push(baseRing);
    
    // Selected rings (shown when star is selected)
    if (eventData.isSelected) {
      for (let i = 0; i < 2; i++) {
        const selectedRingTexture = createOrbitalRingTexture(color, 'selected');
        const selectedRingMaterial = new THREE.SpriteMaterial({ 
          map: selectedRingTexture, 
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        });
        const selectedRing = new THREE.Sprite(selectedRingMaterial);
        selectedRing.position.copy(starSprite.position);
        selectedRing.scale.setScalar(starSprite.scale.x * (2.5 + i * 0.5));
        selectedRing.userData = {
          type: 'selected',
          parentStar: eventData.slug,
          animationPhase: Math.random() * Math.PI * 2 + i * Math.PI,
          rotationSpeed: 0.001 * (i + 1),
          pulseSpeed: 0.002,
          scaleBase: starSprite.scale.x * (2.5 + i * 0.5)
        };
        rings.push(selectedRing);
      }
    }
    
    // Initialization ring (expanding ring effect)
    if (!orbitalRings.has(eventData.slug)) { // Only on first creation
      const initRingTexture = createOrbitalRingTexture(color, 'init');
      const initRingMaterial = new THREE.SpriteMaterial({ 
        map: initRingTexture, 
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending
      });
      const initRing = new THREE.Sprite(initRingMaterial);
      initRing.position.copy(starSprite.position);
      initRing.scale.setScalar(starSprite.scale.x * 0.2);
      initRing.userData = {
        type: 'init',
        parentStar: eventData.slug,
        startTime: Date.now(),
        duration: 3000, // 3 seconds
        scaleStart: starSprite.scale.x * 0.2,
        scaleEnd: starSprite.scale.x * 5
      };
      rings.push(initRing);
    }
    
    return rings;
  }

  // Update orbital ring animations
  function updateOrbitalRings() {
    const currentTime = Date.now();
    
    orbitalRings.forEach((rings, starSlug) => {
      rings.forEach((ring, index) => {
        const userData = ring.userData;
        
        if (userData.type === 'base') {
          // Gentle rotation and subtle pulse
          userData.animationPhase += userData.rotationSpeed;
          ring.rotation.z = userData.animationPhase;
          
          const pulse = 0.1 + Math.sin(currentTime * 0.001 + userData.animationPhase) * 0.05;
          ring.material.opacity = pulse;
          
        } else if (userData.type === 'selected') {
          // Expanding pulse animation
          userData.animationPhase += userData.rotationSpeed;
          ring.rotation.z = userData.animationPhase;
          
          const pulsePhase = Math.sin(currentTime * userData.pulseSpeed + userData.animationPhase);
          const scale = userData.scaleBase * (0.9 + pulsePhase * 0.3);
          ring.scale.setScalar(scale);
          
          const opacity = 0.3 + Math.abs(pulsePhase) * 0.5;
          ring.material.opacity = opacity;
          
        } else if (userData.type === 'init') {
          // Expanding initialization effect
          const elapsed = currentTime - userData.startTime;
          const progress = Math.min(elapsed / userData.duration, 1);
          
          if (progress >= 1) {
            // Remove completed init rings
            if (ring.parent) ring.parent.remove(ring);
            rings.splice(index, 1);
            return;
          }
          
          // Expanding scale with easing
          const easeOut = 1 - Math.pow(1 - progress, 3);
          const scale = userData.scaleStart + (userData.scaleEnd - userData.scaleStart) * easeOut;
          ring.scale.setScalar(scale);
          
          // Fading opacity
          ring.material.opacity = 0.9 * (1 - progress);
        }
      });
    });
  }

  // Advanced StarNode-inspired texture creation with full animation support
  function createAdvancedStarTexture(color, starType, isKeyEvent = false, isSelected = false, isHovered = false, animationTime = 0, size = 512) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    const center = size / 2;
    const baseRadius = isKeyEvent ? size * 0.04 : size * 0.03;
    const sizeFactor = getSizeFactor(isKeyEvent);
    const finalRadius = baseRadius * sizeFactor;
    
    // Clear canvas
    ctx.clearRect(0, 0, size, size);
    
    // Slower animation calculations
    const glowPhase = (Math.sin(animationTime * 0.0008) + 1) / 2; // 0-1 oscillation (slower)
    const shimmerPhase = (Math.sin(animationTime * 0.001) + 1) / 2;
    const orbitalPhase = animationTime * 0.0004;
    const raysRotation = animationTime * 0.0003;
    
    // Backing plate (from StarNode) - enhanced for 3D
    const backingRadius = finalRadius * 4;
    const backingGradient = ctx.createRadialGradient(center, center, 0, center, center, backingRadius);
    const backingOpacity = isSelected ? 0.95 : (isHovered ? 0.9 : 0.7);
    backingGradient.addColorStop(0, `rgba(0,0,0,${backingOpacity})`);
    backingGradient.addColorStop(0.7, `rgba(0,0,0,${backingOpacity * 0.6})`);
    backingGradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = backingGradient;
    ctx.beginPath();
    ctx.arc(center, center, backingRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Enhanced multi-layer glow with proper boundary fadeout
    const glowLayers = [
      { radius: finalRadius * 20, opacity: 0.02 + glowPhase * 0.01, blur: 30 },
      { radius: finalRadius * 15, opacity: 0.04 + glowPhase * 0.02, blur: 25 },
      { radius: finalRadius * 12, opacity: 0.06 + glowPhase * 0.03, blur: 20 },
      { radius: finalRadius * 8, opacity: 0.1 + glowPhase * 0.05, blur: 15 },
      { radius: finalRadius * 5, opacity: 0.15 + glowPhase * 0.08, blur: 10 },
      { radius: finalRadius * 3, opacity: 0.25 + glowPhase * 0.1, blur: 5 },
    ];
    
    // Color shifting effect (slower)
    const hueShift = Math.sin(animationTime * 0.0004) * 20; // Â±20 degree hue shift (slower)
    const brightness = 1 + Math.sin(animationTime * 0.0006) * 0.15; // brightness oscillation (slower)
    
    glowLayers.forEach((layer, index) => {
      ctx.save();
      ctx.filter = `blur(${layer.blur}px) hue-rotate(${hueShift * (index + 1) / glowLayers.length}deg) brightness(${brightness})`;
      
      const gradient = ctx.createRadialGradient(center, center, 0, center, center, layer.radius);
      const alpha = Math.floor(layer.opacity * 255).toString(16).padStart(2, '0');
      gradient.addColorStop(0, color + alpha);
      gradient.addColorStop(0.2, color + Math.floor(layer.opacity * 180).toString(16).padStart(2, '0'));
      gradient.addColorStop(0.5, color + Math.floor(layer.opacity * 100).toString(16).padStart(2, '0'));
      gradient.addColorStop(0.8, color + Math.floor(layer.opacity * 40).toString(16).padStart(2, '0'));
      gradient.addColorStop(1, color + '00'); // Completely transparent at edge
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(center, center, layer.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
    
    // Light rays effect (from StarNode) - animated rotation
    if (isKeyEvent || isSelected || isHovered) {
      ctx.save();
      ctx.translate(center, center);
      ctx.rotate(raysRotation);
      ctx.translate(-center, -center);
      
      const raysRadius = finalRadius * 10;
      const raysOpacity = isSelected ? 0.3 : (isHovered ? 0.18 : (isKeyEvent ? 0.2 : 0.15));
      
      // Create repeating conic gradient for rays
      const rayCount = 8;
      for (let i = 0; i < rayCount; i++) {
        const angle = (i / rayCount) * Math.PI * 2;
        const rayLength = raysRadius * (0.8 + Math.sin(animationTime * 0.003 + i) * 0.2);
        
        ctx.strokeStyle = color + Math.floor(raysOpacity * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(center, center);
        ctx.lineTo(
          center + Math.cos(angle) * rayLength,
          center + Math.sin(angle) * rayLength
        );
        ctx.stroke();
      }
      ctx.restore();
    }
    
    // Orbital rings (from StarNode orbital effects)
    if (isSelected || isHovered) {
      const orbitalRings = isSelected ? [
        { radius: finalRadius * 8, opacity: 0.8, speed: 1, width: 2 },
        { radius: finalRadius * 6.5, opacity: 0.6, speed: -0.7, width: 1.5 },
      ] : [
        { radius: finalRadius * 6, opacity: 0.4, speed: 0.8, width: 1 },
      ];
      
      orbitalRings.forEach((ring, index) => {
        ctx.save();
        const ringPhase = orbitalPhase * ring.speed + index * Math.PI;
        const ringOpacity = ring.opacity * (0.7 + Math.sin(ringPhase * 2) * 0.3);
        const ringRadius = ring.radius * (0.9 + Math.sin(ringPhase * 1.5) * 0.1);
        
        ctx.strokeStyle = color + Math.floor(ringOpacity * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = ring.width;
        ctx.setLineDash([3, 2]);
        ctx.lineDashOffset = ringPhase * 10;
        ctx.beginPath();
        ctx.arc(center, center, ringRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      });
    }
    
    // Main star shape with shimmer effect (from StarNode)
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    
    // Shimmer brightness calculation
    const shimmerBrightness = 1 + shimmerPhase * 0.3;
    ctx.filter = `brightness(${shimmerBrightness}) drop-shadow(0 0 ${finalRadius * 0.5}px ${color})`;
    
    switch (starType) {
      case 'point':
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(center, center, finalRadius * 1.2, 0, Math.PI * 2);
        ctx.fill();
        break;
        
      case 'classic':
        drawStar(ctx, center, center, 5, finalRadius * 2, finalRadius * 1, color);
        break;
        
      case 'sparkle':
        drawStar(ctx, center, center, 4, finalRadius * 1.8, finalRadius * 0.8, color);
        // Add animated cross lines
        const crossOpacity = 0.4 + shimmerPhase * 0.6;
        ctx.strokeStyle = color + Math.floor(crossOpacity * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(center - finalRadius * 3, center);
        ctx.lineTo(center + finalRadius * 3, center);
        ctx.moveTo(center, center - finalRadius * 3);
        ctx.lineTo(center, center + finalRadius * 3);
        ctx.stroke();
        break;
        
      case 'refraction':
        // Central core
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(center, center, finalRadius * 1.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Animated refraction lines (from StarNode refractionTwinkle)
        const refractionOpacity = 0.2 + Math.sin(animationTime * 0.0025) * 0.4;
        ctx.strokeStyle = color + Math.floor(refractionOpacity * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(center - finalRadius * 4, center);
        ctx.lineTo(center + finalRadius * 4, center);
        ctx.moveTo(center, center - finalRadius * 4);
        ctx.lineTo(center, center + finalRadius * 4);
        ctx.stroke();
        
        // Diagonal refraction lines
        const diagOpacity = refractionOpacity * 0.6;
        ctx.strokeStyle = color + Math.floor(diagOpacity * 255).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.moveTo(center - finalRadius * 2.8, center - finalRadius * 2.8);
        ctx.lineTo(center + finalRadius * 2.8, center + finalRadius * 2.8);
        ctx.moveTo(center - finalRadius * 2.8, center + finalRadius * 2.8);
        ctx.lineTo(center + finalRadius * 2.8, center - finalRadius * 2.8);
        ctx.stroke();
        break;
        
      case 'halo':
        // Multiple breathing halos (from StarNode haloBreathing)
        const breathingPhase = Math.sin(animationTime * 0.0015);
        const haloRings = [
          { radius: finalRadius * (1.2 + breathingPhase * 0.2), opacity: 1 },
          { radius: finalRadius * (2 + breathingPhase * 0.3), opacity: 0.6 },
          { radius: finalRadius * (2.8 + breathingPhase * 0.4), opacity: 0.3 },
          { radius: finalRadius * (3.6 + breathingPhase * 0.5), opacity: 0.15 }
        ];
        
        haloRings.forEach(ring => {
          const ringOpacity = ring.opacity * (0.4 + breathingPhase * 0.2);
          ctx.fillStyle = color + Math.floor(ringOpacity * 255).toString(16).padStart(2, '0');
          ctx.beginPath();
          ctx.arc(center, center, ring.radius, 0, Math.PI * 2);
          ctx.fill();
        });
        break;
        
      default: // subtle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(center, center, finalRadius * 1.1, 0, Math.PI * 2);
        ctx.fill();
        
        const subtleOpacity = 0.6 + shimmerPhase * 0.4;
        ctx.strokeStyle = color + Math.floor(subtleOpacity * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(center - finalRadius * 2.5, center);
        ctx.lineTo(center + finalRadius * 2.5, center);
        ctx.moveTo(center, center - finalRadius * 2.5);
        ctx.lineTo(center, center + finalRadius * 2.5);
        ctx.stroke();
        break;
    }
    
    // Enhanced center glow for key events (from StarNode innerGlowPulse)
    if (isKeyEvent) {
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      const pulsePhase = Math.sin(animationTime * 0.002);
      const glowRadius = finalRadius * (2.5 + pulsePhase * 0.7);
      const glowOpacity = 0.4 + pulsePhase * 0.2;
      
      const centerGlow = ctx.createRadialGradient(center, center, 0, center, center, glowRadius);
      centerGlow.addColorStop(0, color);
      centerGlow.addColorStop(0.3, color + Math.floor(glowOpacity * 255).toString(16).padStart(2, '0'));
      centerGlow.addColorStop(1, color + '00');
      ctx.fillStyle = centerGlow;
      ctx.beginPath();
      ctx.arc(center, center, glowRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    ctx.restore();
    
    return new THREE.CanvasTexture(canvas);
  }
  
  // Helper function to draw star shapes
  function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, color) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    const step = Math.PI / spikes;
    
    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    
    for (let i = 0; i < spikes; i++) {
      x = cx + Math.cos(rot) * outerRadius;
      y = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;
      
      x = cx + Math.cos(rot) * innerRadius;
      y = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  // Card rendering function
  function renderCard(eventData, screenPosition) {
    floatingCard = floatingCard || document.getElementById(floatingCardId);
    if (!floatingCard) return;

    if (!eventData || !screenPosition) {
      floatingCard.style.opacity = '0';
      floatingCard.style.pointerEvents = 'none';
      floatingCard.innerHTML = '';
      selectedEvent = null;
      return;
    }

    const container = document.getElementById(mapId);
    const rect = container.getBoundingClientRect();
    
    let { x, y } = screenPosition;
    let positionClass = 'timeline-card-bottom';
    
    const cardWidth = 200;
    const cardHeight = 100;
    const margin = 20;
    
    // Adjust position to avoid edges
    if (x < margin + cardWidth/2) {
      x = x + margin;
      positionClass = 'timeline-card-right';
    } else if (x > rect.width - margin - cardWidth/2) {
      x = x - cardWidth - margin;
      positionClass = 'timeline-card-left';
    } else {
      x = x - cardWidth/2;
    }

    if (y < margin + cardHeight) {
      y = y + margin;
      positionClass = 'timeline-card-bottom';
    } else {
      y = y - cardHeight - margin;
      positionClass = 'timeline-card-top';
    }

    const cardHTML = `
      <div class="timeline-card card-base absolute z-30 ${positionClass} bg-[var(--card-bg)] backdrop-blur-sm shadow-lg w-[200px] p-3">
        <div class="font-bold text-75 text-sm mb-1 card-title">${eventData.title}</div>
        <div class="text-50 text-xs line-clamp-2 card-description">${eventData.description || ''}</div>
        <a href="/posts/${eventData.slug}/#post-container" class="timeline-link text-[0.65rem] mt-1 inline-block py-0.5 px-1.5 rounded-full bg-[oklch(0.9_0.05_var(--hue))/0.1] dark:bg-[oklch(0.3_0.05_var(--hue))/0.2] text-[oklch(0.4_0.05_var(--hue))] dark:text-[oklch(0.9_0.05_var(--hue))]">View Event &rarr;</a>
        <div class="card-pointer absolute bg-inherit"></div>
      </div>
    `;
    
    floatingCard.innerHTML = cardHTML;
    floatingCard.style.left = `${x}px`;
    floatingCard.style.top = `${y}px`;
    floatingCard.style.opacity = '1';
    floatingCard.style.pointerEvents = 'auto';
    
    selectedEvent = eventData;
  }

  // Constellation configuration for each era
  const constellationConfig = {
    'ancient-epoch': {
      centerAzimuth: 0,
      centerElevation: 45,
      spread: 40,
      pattern: 'ancient_wisdom'
    },
    'awakening-era': {
      centerAzimuth: 60,
      centerElevation: 50,
      spread: 35,
      pattern: 'rising_dawn'
    },
    'golden-age': {
      centerAzimuth: 120,
      centerElevation: 55,
      spread: 45,
      pattern: 'crown'
    },
    'conflict-epoch': {
      centerAzimuth: 180,
      centerElevation: 40,
      spread: 40,
      pattern: 'crossed_swords'
    },
    'singularity-conflict': {
      centerAzimuth: 240,
      centerElevation: 45,
      spread: 35,
      pattern: 'supernova'
    },
    'transcendent-age': {
      centerAzimuth: 300,
      centerElevation: 60,
      spread: 40,
      pattern: 'ascension'
    },
    'final-epoch': {
      centerAzimuth: 340,
      centerElevation: 65,
      spread: 30,
      pattern: 'omega'
    },
    'unknown': {
      centerAzimuth: 30,
      centerElevation: 35,
      spread: 25,
      pattern: 'scattered'
    }
  };

  // Constellation patterns
  const constellationPatterns = {
    ancient_wisdom: [
      { azOffset: 0, elOffset: 0 },
      { azOffset: -15, elOffset: 10 },
      { azOffset: 15, elOffset: 8 },
      { azOffset: -8, elOffset: -12 },
      { azOffset: 12, elOffset: -10 },
      { azOffset: 0, elOffset: 20 },
      { azOffset: -20, elOffset: -5 },
      { azOffset: 25, elOffset: -8 }
    ],
    rising_dawn: [
      { azOffset: -10, elOffset: -15 },
      { azOffset: 0, elOffset: 0 },
      { azOffset: 10, elOffset: 15 },
      { azOffset: -5, elOffset: 8 },
      { azOffset: 5, elOffset: 8 },
      { azOffset: 15, elOffset: 25 },
      { azOffset: -15, elOffset: 20 }
    ],
    crown: [
      { azOffset: 0, elOffset: 15 },
      { azOffset: -12, elOffset: 8 },
      { azOffset: 12, elOffset: 8 },
      { azOffset: -6, elOffset: 0 },
      { azOffset: 6, elOffset: 0 },
      { azOffset: -20, elOffset: -5 },
      { azOffset: 20, elOffset: -5 },
      { azOffset: 0, elOffset: -10 }
    ],
    crossed_swords: [
      { azOffset: -15, elOffset: 15 },
      { azOffset: 15, elOffset: -15 },
      { azOffset: 15, elOffset: 15 },
      { azOffset: -15, elOffset: -15 },
      { azOffset: 0, elOffset: 0 },
      { azOffset: -25, elOffset: 10 },
      { azOffset: 25, elOffset: -10 }
    ],
    supernova: [
      { azOffset: 0, elOffset: 0 },
      { azOffset: 0, elOffset: 20 },
      { azOffset: 17, elOffset: 10 },
      { azOffset: 20, elOffset: 0 },
      { azOffset: 17, elOffset: -10 },
      { azOffset: 0, elOffset: -20 },
      { azOffset: -17, elOffset: -10 },
      { azOffset: -20, elOffset: 0 },
      { azOffset: -17, elOffset: 10 }
    ],
    ascension: [
      { azOffset: 0, elOffset: 25 },
      { azOffset: -8, elOffset: 15 },
      { azOffset: 8, elOffset: 15 },
      { azOffset: -15, elOffset: 5 },
      { azOffset: 15, elOffset: 5 },
      { azOffset: -20, elOffset: -10 },
      { azOffset: 20, elOffset: -10 },
      { azOffset: 0, elOffset: -5 }
    ],
    omega: [
      { azOffset: -10, elOffset: 10 },
      { azOffset: 10, elOffset: 10 },
      { azOffset: -15, elOffset: 0 },
      { azOffset: 15, elOffset: 0 },
      { azOffset: -8, elOffset: -10 },
      { azOffset: 8, elOffset: -10 },
      { azOffset: 0, elOffset: 5 }
    ],
    scattered: [
      { azOffset: 5, elOffset: 8 },
      { azOffset: -12, elOffset: -5 },
      { azOffset: 18, elOffset: 12 },
      { azOffset: -8, elOffset: 15 },
      { azOffset: 10, elOffset: -10 },
      { azOffset: -15, elOffset: 3 }
    ]
  };

  // Create or update stars as era-based constellations with full StarNode graphics
  function createOrUpdateStars(eventsToDisplay = currentEvents) {
    if (!starsGroup || !THREE) {
      console.warn('Starmap: createOrUpdateStars called before initialization.');
      return;
    }

    // Clear existing stars and orbital rings
    while (starsGroup.children.length > 0) {
      starsGroup.remove(starsGroup.children[0]);
    }
    starSprites.clear();
    orbitalRings.clear();
    
    // Group events by era
    const eventsByEra = {};
    const unassignedEvents = [];
    
    eventsToDisplay.forEach(event => {
      const era = event.era || 'unknown';
      
      if (!constellationConfig[era]) {
        console.warn(`Event "${event.title}" has era "${era}" but no constellation config exists. Adding to 'unknown'.`);
        unassignedEvents.push(event);
        if (!eventsByEra['unknown']) {
          eventsByEra['unknown'] = [];
        }
        eventsByEra['unknown'].push(event);
        return;
      }
      
      if (!eventsByEra[era]) {
        eventsByEra[era] = [];
      }
      eventsByEra[era].push(event);
    });

    console.log('Starmap: Events grouped by era:', Object.keys(eventsByEra).map(era => `${era}: ${eventsByEra[era].length}`).join(', '));

    // Create constellations for each era
    Object.entries(eventsByEra).forEach(([era, eraEvents]) => {
      const config = constellationConfig[era];
      if (!config) {
        console.error(`No constellation config for era: ${era}`);
        return;
      }

      const pattern = constellationPatterns[config.pattern] || constellationPatterns.scattered;
      
      eraEvents.forEach((event, eventIndex) => {
        try {
          // Get position within constellation pattern
          const patternIndex = eventIndex % pattern.length;
          const patternPosition = pattern[patternIndex];
          
          // Add some variation for events beyond the pattern length
          const extraVariation = eventIndex >= pattern.length ? 
            { azOffset: (Math.random() - 0.5) * 30, elOffset: (Math.random() - 0.5) * 20 } : 
            { azOffset: 0, elOffset: 0 };

          // Calculate final position
          const azimuthDeg = config.centerAzimuth + patternPosition.azOffset + extraVariation.azOffset;
          const elevationDeg = Math.max(30, Math.min(80, config.centerElevation + patternPosition.elOffset + extraVariation.elOffset));
          
          const azimuthRad = (azimuthDeg * Math.PI) / 180;
          const elevationRad = (elevationDeg * Math.PI) / 180;
          const polarAngleRad = Math.PI/2 - elevationRad;

          const uniqueStarId = `${event.slug}-${event.year}-${eventIndex}`;
          const mainColor = getStarColor(uniqueStarId, event.era, useEraColors);
          const starType = getStarType(uniqueStarId, event.isKeyEvent);
          
          // Create advanced star sprite texture with initial state
          const starTexture = createAdvancedStarTexture(mainColor, starType, event.isKeyEvent, false, false, animationStartTime);
          const spriteMaterial = new THREE.SpriteMaterial({ 
            map: starTexture, 
            transparent: true,
            alphaTest: 0.01,
            blending: THREE.AdditiveBlending
          });
          
          const sprite = new THREE.Sprite(spriteMaterial);
          
          // Position on the same sphere as skybox (but slightly closer to avoid z-fighting)
          const radius = 995; // Slightly inside the skybox
          sprite.position.setFromSphericalCoords(radius, polarAngleRad, azimuthRad);
          
          // Scale based on importance and add slight variation
          const baseScale = event.isKeyEvent ? 22 : 16;
          const scaleVariation = 0.8 + (Math.random() * 0.4); // 0.8 to 1.2 multiplier
          sprite.scale.setScalar(baseScale * scaleVariation);
          
          // Store event data and animation state on the sprite for interaction
          sprite.userData = {
            ...event,
            mainColor,
            starType,
            uniqueId: uniqueStarId,
            era: era,
            constellationPosition: patternPosition,
            isSelected: false,
            isHovered: false,
            animationStartTime: Date.now(),
            lastUpdateTime: Date.now()
          };
          
          starsGroup.add(sprite);
          starSprites.set(event.slug, sprite);
          
          // Create orbital rings for this star
          const rings = createOrbitalRingsForStar(sprite, sprite.userData);
          rings.forEach(ring => starsGroup.add(ring));
          orbitalRings.set(event.slug, rings);
        } catch (error) {
          console.error(`Error creating star for event "${event.title}":`, error);
        }
      });
    });
    
    console.log(`Starmap: Created constellations for ${Object.keys(eventsByEra).length} eras with ${eventsToDisplay.length} total stars`);
    
    // Create constellation connecting lines
    createConstellationLines(eventsByEra);
  }

  // Create connecting lines between stars in the same constellation
  function createConstellationLines(eventsByEra) {
    Object.entries(eventsByEra).forEach(([era, eraEvents]) => {
      if (eraEvents.length < 2) return;
      
      const config = constellationConfig[era];
      if (!config) {
        console.warn(`No constellation config found for era: ${era}`);
        return;
      }
      
      // Define constellation connection patterns for each type
      const connectionPatterns = {
        ancient_wisdom: [[0,1], [0,2], [1,5], [2,5], [0,3], [0,4]], // Star formation
        rising_dawn: [[0,1], [1,2], [1,3], [1,4], [2,5], [2,6]], // Rising pattern
        crown: [[0,1], [0,2], [1,3], [2,4], [3,7], [4,7], [5,6]], // Crown shape
        crossed_swords: [[0,4], [1,4], [2,4], [3,4], [4,5], [4,6]], // Cross pattern
        supernova: [[0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7], [0,8]], // Radial
        ascension: [[0,1], [0,2], [1,3], [2,4], [3,5], [4,6], [7,1], [7,2]], // Ascending
        omega: [[0,1], [2,3], [4,5], [0,6], [1,6], [2,4], [3,5]], // Omega shape
        scattered: [[0,1], [1,2], [2,3]] // Simple connections
      };
      
      const connections = connectionPatterns[config.pattern] || connectionPatterns.scattered;
      const linePositions = [];
      
      connections.forEach(([startIdx, endIdx]) => {
        if (startIdx < eraEvents.length && endIdx < eraEvents.length) {
          const startSprite = starSprites.get(eraEvents[startIdx].slug);
          const endSprite = starSprites.get(eraEvents[endIdx].slug);
          
          if (startSprite && endSprite) {
            linePositions.push(startSprite.position.clone());
            linePositions.push(endSprite.position.clone());
          }
        }
      });
      
      if (linePositions.length > 0) {
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePositions);
        
        // Create dashed line material for better constellation visibility
        const lineMaterial = new THREE.LineDashedMaterial({ 
          color: eraColorMap[era] || '#6366f1',
          transparent: true,
          opacity: 0.4,
          linewidth: 2,
          dashSize: 3,
          gapSize: 2
        });
        
        const constellationLine = new THREE.LineSegments(lineGeometry, lineMaterial);
        constellationLine.computeLineDistances(); // Required for dashed lines
        starsGroup.add(constellationLine);
      }
    });
  }

  // Update star animations and states
  function updateStarAnimations() {
    const currentTime = Date.now();
    
    starSprites.forEach((sprite, slug) => {
      const userData = sprite.userData;
      if (!userData) return;
      
      const timeSinceCreation = currentTime - userData.animationStartTime;
      
      // Regenerate texture with current animation state (less frequently for performance)
      if (currentTime - userData.lastUpdateTime > 150) { // Update every 150ms instead of 100ms
        const newTexture = createAdvancedStarTexture(
          userData.mainColor,
          userData.starType,
          userData.isKeyEvent,
          userData.isSelected,
          userData.isHovered,
          timeSinceCreation
        );
        
        // Update material
        if (sprite.material && sprite.material.map) {
          sprite.material.map.dispose();
          sprite.material.map = newTexture;
          sprite.material.needsUpdate = true;
        }
        
        userData.lastUpdateTime = currentTime;
      }
    });
    
    // Update orbital rings
    updateOrbitalRings();
  }

  // Handle star interactions with state management and orbital rings
  function handleStarClick(intersectedSprite) {
    const eventData = intersectedSprite.userData;
    
    // Update selection states and manage orbital rings
    starSprites.forEach((sprite, slug) => {
      const wasSelected = sprite.userData.isSelected;
      sprite.userData.isSelected = sprite === intersectedSprite;
      sprite.userData.isHovered = false;
      
      // Update visual opacity
      if (sprite.material && sprite.material.opacity !== undefined) {
        sprite.material.opacity = sprite === intersectedSprite ? 1.0 : 0.7;
      }
      
      // Manage orbital rings for selection changes
      if (wasSelected !== sprite.userData.isSelected) {
        updateOrbitalRingsForStar(sprite, sprite.userData);
      }
    });
    
    if (selectedEvent && selectedEvent.slug === eventData.slug) {
      // Clicking same star - deselect
      renderCard(null);
      starSprites.forEach((sprite, slug) => {
        sprite.userData.isSelected = false;
        if (sprite.material && sprite.material.opacity !== undefined) sprite.material.opacity = 1.0;
        updateOrbitalRingsForStar(sprite, sprite.userData);
      });
    } else {
      // Select new star
      const screenPosition = getScreenPosition(intersectedSprite);
      renderCard(eventData, screenPosition);
      
      // Dispatch event
      const container = document.getElementById(mapId);
      container.dispatchEvent(new CustomEvent('starmap:selectstar', {
        detail: { 
          slug: eventData.slug, 
          eventData: eventData,
          screenPosition: screenPosition
        },
        bubbles: true,
        composed: true
      }));
    }
  }

  // Update orbital rings for a specific star based on its state
  function updateOrbitalRingsForStar(starSprite, eventData) {
    const currentRings = orbitalRings.get(eventData.slug) || [];
    
    // Remove existing selected rings
    currentRings.forEach((ring, index) => {
      if (ring.userData.type === 'selected') {
        if (ring.parent) ring.parent.remove(ring);
        currentRings.splice(index, 1);
      }
    });
    
    // Add new selected rings if star is selected
    if (eventData.isSelected) {
      for (let i = 0; i < 2; i++) {
        const selectedRingTexture = createOrbitalRingTexture(eventData.mainColor, 'selected');
        const selectedRingMaterial = new THREE.SpriteMaterial({ 
          map: selectedRingTexture, 
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        });
        const selectedRing = new THREE.Sprite(selectedRingMaterial);
        selectedRing.position.copy(starSprite.position);
        selectedRing.scale.setScalar(starSprite.scale.x * (2.5 + i * 0.5));
        selectedRing.userData = {
          type: 'selected',
          parentStar: eventData.slug,
          animationPhase: Math.random() * Math.PI * 2 + i * Math.PI,
          rotationSpeed: 0.001 * (i + 1),
          pulseSpeed: 0.002,
          scaleBase: starSprite.scale.x * (2.5 + i * 0.5)
        };
        currentRings.push(selectedRing);
        starsGroup.add(selectedRing);
      }
    }
    
    orbitalRings.set(eventData.slug, currentRings);
  }

  // Handle star hover states
  function handleStarHover(intersectedSprite, isHovering) {
    if (intersectedSprite && intersectedSprite.userData) {
      intersectedSprite.userData.isHovered = isHovering;
    }
  }

  // Get screen position of 3D object
  function getScreenPosition(object3D) {
    const container = document.getElementById(mapId);
    const vector = new THREE.Vector3();
    
    vector.setFromMatrixPosition(object3D.matrixWorld);
    vector.project(camera);
    
    const widthHalf = container.clientWidth / 2;
    const heightHalf = container.clientHeight / 2;
    
    return {
      x: (vector.x * widthHalf) + widthHalf,
      y: -(vector.y * heightHalf) + heightHalf
    };
  }

  // Update card position during camera movement
  function updateCardPosition() {
    if (!selectedEvent || !floatingCard || floatingCard.style.opacity === '0') return;
    
    const selectedSprite = starSprites.get(selectedEvent.slug);
    if (selectedSprite) {
      const screenPosition = getScreenPosition(selectedSprite);
      
      // Check if star is visible (not behind camera)
      const vector = new THREE.Vector3();
      vector.setFromMatrixPosition(selectedSprite.matrixWorld);
      vector.project(camera);
      
      if (vector.z < 1) { // Star is in front of camera
        floatingCard.style.left = `${screenPosition.x - 100}px`;
        floatingCard.style.top = `${screenPosition.y - 120}px`;
      } else {
        // Star is behind camera - hide card
        renderCard(null);
      }
    }
  }

  // Initialize scene and objects
  function initSceneAndObjects() {
    const container = document.getElementById(mapId);
    if (!container || !THREE) return;

    const width = container.clientWidth;
    const height = container.clientHeight;
    
    if (width === 0 || height === 0) {
      console.warn(`Starmap: Container dimensions are zero (W: ${width}, H: ${height}).`);
    }

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, width / Math.max(1, height), 0.1, 2000);
    camera.position.set(0, 0, 0.01);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, Math.max(1, height));
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Setup raycaster for star interaction
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Load skybox
    const textureLoader = new THREE.TextureLoader();
    const skyTexture = textureLoader.load(skyboxImageUrl,
      () => { console.log('Starmap: Skybox texture loaded.') },
      undefined,
      (err) => console.error('Starmap: Error loading skybox texture:', err)
    );
    skyTexture.mapping = THREE.EquirectangularReflectionMapping;
    const skyMaterial = new THREE.MeshBasicMaterial({ map: skyTexture, side: THREE.BackSide });
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(1000, 60, 40), skyMaterial));

    // Create groups
    starsGroup = new THREE.Group();
    scene.add(starsGroup);
    
    gridGroup = new THREE.Group();
    scene.add(gridGroup);
    
    createGrid();
    createOrUpdateStars();

    // Setup controls
    controls = new OrbitControls(camera, renderer.domElement);
    Object.assign(controls, {
      enableDamping: true,
      dampingFactor: 0.25,
      rotateSpeed: 0.25,
      enablePan: false,
      enableZoom: false,
      minPolarAngle: THREE.MathUtils.degToRad(120),
      maxPolarAngle: THREE.MathUtils.degToRad(170),
      autoRotate: true,
      autoRotateSpeed: 0.05
    });
    controls.target.set(0, 0, 0);
    controls.update();

    // FOV Zoom
    const minFov = 15;
    const maxFov = 45;
    const fovStep = 2;

    renderer.domElement.addEventListener('wheel', (event) => {
      event.preventDefault();
      if (event.deltaY < 0) {
        camera.fov = Math.max(minFov, camera.fov - fovStep);
      } else {
        camera.fov = Math.min(maxFov, camera.fov + fovStep);
      }
      camera.updateProjectionMatrix();
    }, { passive: false });

    // Mouse interaction with hover support
    let hoveredSprite = null;
    
    function onMouseMove(event) {
      const rect = container.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(starsGroup.children);

      if (intersects.length > 0 && intersects[0].object !== hoveredSprite) {
        // Unhover previous sprite
        if (hoveredSprite) {
          handleStarHover(hoveredSprite, false);
        }
        
        // Hover new sprite
        hoveredSprite = intersects[0].object;
        handleStarHover(hoveredSprite, true);
        container.style.cursor = 'pointer';
      } else if (intersects.length === 0 && hoveredSprite) {
        // Unhover when no intersections
        handleStarHover(hoveredSprite, false);
        hoveredSprite = null;
        container.style.cursor = 'default';
      }
    }

    function onMouseClick(event) {
      const rect = container.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(starsGroup.children);

      if (intersects.length > 0) {
        handleStarClick(intersects[0].object);
      } else {
        // Clicked empty space - deselect
        renderCard(null);
        starSprites.forEach((sprite, slug) => {
          sprite.userData.isSelected = false;
          if (sprite.material && sprite.material.opacity !== undefined) sprite.material.opacity = 1.0;
          updateOrbitalRingsForStar(sprite, sprite.userData);
        });
      }
    }

    container.addEventListener('mousemove', onMouseMove);
    container.addEventListener('click', onMouseClick);
    window.addEventListener('resize', onWindowResize);
    animate();
    
    initialized = true;
    console.log('Starmap: Initialization complete');
  }

  // Create grid
  function createGrid() {
    if (!gridGroup || !THREE) return;
    
    gridGroup.clear(); 
    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x224466, transparent: true, opacity: 0.25 });
    
    for (let i = 0; i < 12; i++) {
      const phi = (i / 12) * Math.PI * 2; 
      const points = [];
      for (let j = 0; j <= 50; j++) { 
        points.push(new THREE.Vector3().setFromSphericalCoords(940, (j / 50) * Math.PI, phi));
      }
      gridGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMaterial));
    }
    
    for (let i = -2; i <= 2; i++) { 
      const elevationAngleDeg = i * 30;
      const polarAngleRad = Math.PI / 2 - THREE.MathUtils.degToRad(elevationAngleDeg);
      
      if (polarAngleRad < 0.01 || polarAngleRad > Math.PI - 0.01) continue;
      
      const points = [];
      for (let j = 0; j <= 60; j++) { 
        points.push(new THREE.Vector3().setFromSphericalCoords(940, polarAngleRad, (j / 60) * Math.PI * 2));
      }
      points.push(points[0]); 
      gridGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMaterial));
    }
  }

  // Animation loop with star animation updates
  function animate() {
    requestAnimationFrame(animate);
    if (!initialized || !controls || !renderer || !scene || !camera) return;
    
    try {
      controls.update();
      renderer.render(scene, camera);
      updateCardPosition();
      
      // Update star animations every few frames for performance
      const currentTime = Date.now();
      if (currentTime % 150 < 16) { // Update approximately every 150ms (slower)
        updateStarAnimations();
      }
    } catch (e) {
      console.error('Starmap: Error in animate loop:', e);
    }
  }

  // Window resize handler
  function onWindowResize() {
    const container = document.getElementById(mapId);
    if (!container || !camera || !renderer) return;
    
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    camera.aspect = width / Math.max(1, height);
    camera.updateProjectionMatrix();
    renderer.setSize(width, Math.max(1, height));
  }

  // Public API
  window[`starmap_${mapId}`] = {
    updateEvents: (newEvents) => {
      currentEvents = newEvents || JSON.parse(starmapEventsJson);
      createOrUpdateStars(currentEvents);
    },
    isInitialized: () => initialized,
    resetView: () => {
      if (controls) {
        controls.reset();
      }
    },
    getConstellationInfo: () => {
      const eventsByEra = {};
      currentEvents.forEach(event => {
        const era = event.era || 'unknown';
        if (!eventsByEra[era]) eventsByEra[era] = [];
        eventsByEra[era].push(event);
      });
      return {
        constellations: Object.keys(eventsByEra).map(era => ({
          era,
          events: eventsByEra[era].length,
          config: constellationConfig[era],
          color: eraColorMap[era]
        }))
      };
    }
  };

  // Initialize Three.js
  async function initializeThreeStarmap() {
    if (initialized) return;

    const container = document.getElementById(mapId);
    if (!container) {
      console.error(`Starmap: Container with ID #${mapId} not found.`);
      return;
    }
    
    const loadingMessageEl = container.querySelector('.starmap-loading-message');
    if (loadingMessageEl) loadingMessageEl.style.display = 'none';

    try {
      const loadScript = (src) => {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = src;
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      };

      if (!window.THREE) {
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js');
      }
      THREE = window.THREE;

      await loadScript('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js');
      OrbitControls = window.THREE.OrbitControls;

      console.log('Starmap: Three.js and dependencies loaded successfully');
      initSceneAndObjects();

    } catch (error) {
      console.error('Starmap: Error during Three.js initialization:', error);
      if (container && loadingMessageEl) {
        loadingMessageEl.textContent = 'Error loading 3D Starmap.';
        loadingMessageEl.style.color = 'red';
        loadingMessageEl.style.display = 'block';
      }
    }
  }

  // Auto-initialize when visible
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && !initialized) {
        initializeThreeStarmap();
        observer.disconnect();
      }
    });
  });

  const containerElement = document.getElementById(mapId);
  if (containerElement) {
    observer.observe(containerElement);
  }
</script>