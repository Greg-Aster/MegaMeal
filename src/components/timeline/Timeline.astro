---
import { Icon } from 'astro-icon/components';
import { getTimelineEvents, getEraDisplayName } from '../../services/TimelineService';
import type { TimelineEvent } from '../../services/TimelineService';
import { getPostUrlBySlug } from '../../utils/url-utils';
import '../../styles/timeline.css'; // Add this import


interface Props {
  class?: string;
  category?: string;         // Optional category filter
  startYear?: number;        // Optional start year (now truly optional)
  endYear?: number;          // Optional end year (now truly optional)
  background?: string;       // Optional background image URL
  compact?: boolean;         // Compact display mode
  asBanner?: boolean;        // Whether to display as a banner
  bannerHeight?: string;     // Height when used as banner
}

// Extract props with defaults
const { 
  class: className = "",
  category = "",
  startYear,
  endYear,
  background = "/assets/banner/0001.png", // Default background
  compact = false,
  asBanner = false,
  bannerHeight = "300px"
} = Astro.props;

// Get timeline events with our service, including banner posts
const timelineOptions = {
  category,
  startYear,
  endYear,
  includeBanners: true
};

const timelineEvents = await getTimelineEvents(timelineOptions);

// If we have events with bannerData, we can use those properties to enhance our timeline
const bannerEvents = timelineEvents.filter(event => event.bannerData);
let timelineBackground = background;
let timelineStartYear = startYear;
let timelineEndYear = endYear;

if (bannerEvents.length > 0) {
  // Prioritize bannerData from the first relevant banner event
  const primaryBanner = bannerEvents[0];
  
  // Use banner background if available
  if (primaryBanner.bannerData?.background) {
    timelineBackground = primaryBanner.bannerData.background;
  }
  
  // Use banner year range if available
  if (primaryBanner.bannerData?.startYear && !timelineStartYear) {
    timelineStartYear = primaryBanner.bannerData.startYear;
  }
  
  if (primaryBanner.bannerData?.endYear && !timelineEndYear) {
    timelineEndYear = primaryBanner.bannerData.endYear;
  }
}

// Calculate timeline range based on actual events if not specified
// This is the key change - dynamic determination of timeline boundaries
let earliestYear: number;
let latestYear: number;

if (timelineEvents.length > 0) {
  // Extract all years from timeline events
  const years = timelineEvents.map(event => event.year);
  
  // Determine earliest and latest years from the events
  const minEventYear = Math.min(...years);
  const maxEventYear = Math.max(...years);
  
  // Handle extreme outliers using a more sophisticated approach
  let effectiveMinYear = minEventYear;
  let effectiveMaxYear = maxEventYear;
  
  // Detect if we have a very wide range that might indicate outliers
  if (maxEventYear - minEventYear > 1000) {
    // Sort all years to analyze distribution
    const sortedYears = [...years].sort((a, b) => a - b);
    
    // Calculate median year (middle of the distribution)
    const medianIndex = Math.floor(sortedYears.length / 2);
    const medianYear = sortedYears[medianIndex];
    
    // Find clusters of events by looking for large gaps between years
    const yearGaps = [];
    for (let i = 1; i < sortedYears.length; i++) {
      const gap = sortedYears[i] - sortedYears[i-1];
      yearGaps.push({ 
        position: i-1, 
        gap: gap, 
        fromYear: sortedYears[i-1],
        toYear: sortedYears[i] 
      });
    }
    
    // Sort gaps by size (largest first)
    yearGaps.sort((a, b) => b.gap - a.gap);
    
    // If we have significant gaps (more than 50% of total range), 
    // use the largest gap to split and focus on the cluster with more events
    if (yearGaps.length > 0 && yearGaps[0].gap > (maxEventYear - minEventYear) * 0.5) {
      const largestGap = yearGaps[0];
      
      // Find which side of the gap has more events
      const beforeGapCount = largestGap.position + 1;
      const afterGapCount = sortedYears.length - largestGap.position - 1;
      
      if (beforeGapCount >= afterGapCount) {
        // More events before the gap, focus on earlier years
        effectiveMaxYear = largestGap.fromYear;
      } else {
        // More events after the gap, focus on later years
        effectiveMinYear = largestGap.toYear;
      }
    } 
    // If no single large gap, fall back to using the middle 80% of events
    else {
      // Find the year range that includes the middle 80% of events
      const startIndex = Math.floor(sortedYears.length * 0.1);
      const endIndex = Math.ceil(sortedYears.length * 0.9) - 1;
      
      effectiveMinYear = sortedYears[startIndex];
      effectiveMaxYear = sortedYears[endIndex];
    }
  }
  
  // Add padding for better visualization (10% of range, minimum 5 years)
  const yearRange = Math.max(effectiveMaxYear - effectiveMinYear, 50);
  const yearPadding = Math.max(5, Math.ceil(yearRange * 0.1));
  
  // Set the years, preferring provided values if they exist
  earliestYear = timelineStartYear !== undefined ? 
    timelineStartYear : 
    effectiveMinYear - yearPadding;
    
  latestYear = timelineEndYear !== undefined ? 
    timelineEndYear : 
    effectiveMaxYear + yearPadding;
    
  // Add debug info to console for troubleshooting
  console.log(`Timeline years: min=${minEventYear}, max=${maxEventYear}, effective min=${effectiveMinYear}, effective max=${effectiveMaxYear}, displayed range=${earliestYear} to ${latestYear}`);
} else {
  // Default values if no events (should rarely happen)
  earliestYear = timelineStartYear || 2000;
  latestYear = timelineEndYear || 2100;
}

// Calculate timespan based on actual years, not fixed values
const timespan = latestYear - earliestYear;

// Add padding to prevent edge cropping (15% on each side)
const PADDING_PERCENT = 15;

// Function to calculate position percentage along timeline with padding
function getPositionPercentage(year: number): number {
  if (timespan === 0) return 50; // Center if only one event
  
  // Handle extreme outliers - clamp years that are outside our display range
  // This ensures all events are visible on the timeline
  const clampedYear = Math.max(earliestYear, Math.min(latestYear, year));
  
  // Calculate base percentage (0-100%)
  const basePercentage = ((clampedYear - earliestYear) / timespan) * 100;
  
  // Apply padding to spread events away from edges
  return PADDING_PERCENT + (basePercentage * (100 - (2 * PADDING_PERCENT)) / 100);
}

// Function to assign a color class based on era
function getEraColorClass(era?: string, isKeyEvent: boolean = false): string {
  if (isKeyEvent) return "text-purple-500";
  
  if (!era) return "text-blue-500";
  
  // Color mapping based on era using Tailwind classes
  switch(era) {
    case 'pre-spork':
      return "text-green-500";
    case 'spork-uprising':
      return "text-yellow-500";
    case 'snuggaloid':
      return "text-red-500";
    case 'post-extinction':
      return "text-indigo-500";
    default:
      return "text-blue-500";
  }
}

// Function to get badge class based on era
function getEraBadgeClass(era?: string): string {
  if (!era) return "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200";
  
  switch(era) {
    case 'pre-spork':
      return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200";
    case 'spork-uprising':
      return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200";
    case 'snuggaloid':
      return "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200";
    case 'post-extinction':
      return "bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200";
    default:
      return "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200";
  }
}

// Create a natural, random distribution of stars
// Instead of strictly top/bottom, we'll use a more varied vertical positioning
const eventPositions: {event: TimelineEvent, verticalPosition: number}[] = [];

// Sort events by year to ensure they're displayed chronologically
const sortedEvents = [...timelineEvents].sort((a, b) => a.year - b.year);

// Assign a random vertical position to each event, but avoid overlaps
sortedEvents.forEach((event, index) => {
  const posPercentage = getPositionPercentage(event.year);
  
  // Generate a random vertical position (-120px to +120px from center line)
  // Using a seeded random based on event properties to ensure consistency
  const seed = event.slug.charCodeAt(0) + event.year % 100; 
  const randomFactor = ((seed * 9301 + 49297) % 233280) / 233280;
  
  // Calculate a position between -120px and +120px, with more probability toward center
  // Using a modified bell curve distribution for more natural star field
  let verticalOffset = (randomFactor * 2 - 1) * 240; // Range -120 to +120
  
  // Apply a subtle curve to keep more stars closer to center line
  verticalOffset = Math.sign(verticalOffset) * Math.pow(Math.abs(verticalOffset) / 120, 1.5) * 120;
  
  // Check for nearby events to prevent obvious overlaps
  let attempts = 0;
  const maxAttempts = 5;
  let finalOffset = verticalOffset;
  
  while (attempts < maxAttempts) {
    // Check if this position would overlap with any existing events
    const wouldOverlap = eventPositions.some(pos => {
      const xDistance = Math.abs(getPositionPercentage(pos.event.year) - posPercentage);
      const yDistance = Math.abs(pos.verticalPosition - finalOffset);
      // Consider an overlap if events are within 8% horizontally and 40px vertically
      return xDistance < 8 && yDistance < 40;
    });
    
    if (!wouldOverlap) break; // Position is good, no overlap
    
    // Adjust position slightly and try again
    finalOffset = verticalOffset + (attempts % 2 === 0 ? 1 : -1) * (30 + attempts * 10);
    attempts++;
  }
  
  // Ensure stars stay within reasonable bounds
  finalOffset = Math.max(-140, Math.min(140, finalOffset));
  
  // Add to positions array
  eventPositions.push({
    event,
    verticalPosition: finalOffset
  });
});

// Generate unique ID for this timeline instance
const timelineId = `timeline-${Math.random().toString(36).substring(2, 10)}`;
---

<div 
  id={timelineId} 
  class={`timeline card-base p-0 relative overflow-hidden ${compact ? 'compact-mode' : 'expanded-mode'} ${asBanner ? 'banner-mode' : ''} ${className}`}
  style={asBanner ? `min-height: ${bannerHeight};` : ''}
  data-start-year={earliestYear}
  data-end-year={latestYear}
>
  <div class="absolute inset-0 z-0 overflow-hidden timeline-background">
    <img 
      src={timelineBackground} 
      alt="Timeline background" 
      class="w-full h-full object-cover transition-transform duration-300 ease-out"
      style="transform-origin: center center; transform: scale(1.05);"
    />
    <div class="absolute inset-0 bg-gradient-to-r from-[oklch(0.25_0.05_var(--hue))] to-[oklch(0.15_0.05_var(--hue))] opacity-20 dark:opacity-10 backdrop-blur-[2px]"></div>
  </div>

  <!-- Timeline container with extra padding for edges -->
  <div class="timeline-container relative z-10 w-full my-0" 
       style={compact ? 'min-height: 180px;' : 
              asBanner ? `min-height: calc(100% - 1rem);` : 'min-height: 300px;'}>
    <!-- Center line - extended past the events -->
    <div class="absolute left-0 right-0 h-0.5 top-1/2 transform -translate-y-1/2 bg-[oklch(0.6_0.1_var(--hue))] dark:bg-[oklch(0.7_0.15_var(--hue))] opacity-20"></div>
    
    <!-- Year markers for start and end -->
    <div class="absolute top-1/2 transform -translate-y-1/2 w-0.5 h-3 bg-[oklch(0.6_0.1_var(--hue))] dark:bg-[oklch(0.7_0.15_var(--hue))] opacity-30" style={`left: ${PADDING_PERCENT}%`}></div>
    <div class="absolute top-1/2 transform -translate-y-1/2 w-0.5 h-3 bg-[oklch(0.6_0.1_var(--hue))] dark:bg-[oklch(0.7_0.15_var(--hue))] opacity-30" style={`left: ${100 - PADDING_PERCENT}%`}></div>
    
    <!-- Additional year markers for each event (very subtle) -->
    {timelineEvents.map(event => (
      <div 
        class="absolute top-1/2 transform -translate-y-1/2 w-0.5 h-2 bg-[oklch(0.6_0.1_var(--hue))] dark:bg-[oklch(0.7_0.15_var(--hue))] opacity-10" 
        style={`left: ${getPositionPercentage(event.year)}%`}
      ></div>
    ))}
    
    {/* All events with varying vertical positions */}
    {eventPositions.map(({ event, verticalPosition }) => (
      <a 
        href={getPostUrlBySlug(event.slug)} 
        class="timeline-event absolute cursor-pointer transform -translate-x-1/2"
        style={`left: ${getPositionPercentage(event.year)}%; top: calc(50% + ${verticalPosition}px);`}
        data-event-id={event.slug}
        data-year={event.year}
        data-era={event.era}
      >
        <div class="timeline-node absolute transform -translate-x-1/2 -translate-y-1/2 star-node">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" class={`star-icon ${getEraColorClass(event.era, event.isKeyEvent)}`}>
            <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" 
                  fill="currentColor" stroke="white" stroke-width="1" />
          </svg>
        </div>
        
        <div class="timeline-card card-base w-[200px] p-3 transform -translate-x-1/2 mb-2 hover:bg-[var(--btn-card-bg-hover)] transition-all opacity-0 pointer-events-none">
          <div class="font-bold text-75 text-sm mb-1">{event.year}: {event.title}</div>
          {!compact && <div class="text-50 text-xs line-clamp-2">{event.description}</div>}
          {event.era && 
            <div class={`timeline-era-badge text-[0.65rem] mt-1 inline-block py-0.5 px-1.5 rounded-full ${getEraBadgeClass(event.era)}`}>
              {getEraDisplayName(event.era)}
            </div>
          }
        </div>
      </a>
    ))}
    
    <!-- Era labels (only if we have events) -->
    {timelineEvents.length > 0 && (
      <>
        <div class="absolute top-0 left-[15%] p-2 text-lg font-bold text-75">
          {earliestYear}
        </div>
        <div class="absolute top-0 right-[15%] p-2 text-lg font-bold text-75">
          {latestYear}
        </div>
      </>
    )}
  </div>
  
  <!-- Handle case with no events -->
  {timelineEvents.length === 0 && (
    <div class="flex flex-col items-center justify-center py-10 text-center">
      <Icon name="material-symbols:schedule-outline-rounded" class="text-[3rem] text-[oklch(0.6_0.1_var(--hue))] mb-4" />
      <div class="text-75 font-bold">No timeline events found</div>
      <div class="text-50 text-sm mt-2">
        Add timelineYear property to your post frontmatter to create timeline events
      </div>
    </div>
  )}
</div>

<!-- In Timeline.astro, find the <script> section and update the initTimelineInteractions function -->

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Find all timeline elements and initialize them
    document.querySelectorAll('.timeline').forEach(timeline => {
      const id = timeline.id;
      if (id) initTimelineInteractions(id);
    });
  });
  
  document.addEventListener('astro:page-load', () => {
    // Re-initialize after page transitions
    document.querySelectorAll('.timeline').forEach(timeline => {
      const id = timeline.id;
      if (id) initTimelineInteractions(id);
    });
  });
  
  function initTimelineInteractions(id) {
    const timelineEl = document.getElementById(id);
    if (!timelineEl) return;
    
    // Find all timeline events
    const timelineEvents = timelineEl.querySelectorAll('.timeline-event');
    
    // Track which event is currently selected by a click
    let selectedEvent = null;
    
    timelineEvents.forEach(event => {
      // Get the timeline card and star node for this event
      const card = event.querySelector('.timeline-card');
      const starNode = event.querySelector('.star-node');
      
      if (!card || !starNode) return;
      
      // Add hover behavior for desktop devices
      if (!('ontouchstart' in window)) {
        // Show card on hover
        event.addEventListener('mouseenter', () => {
          // Only show on hover if this isn't the clicked/selected event
          if (selectedEvent !== event) {
            // Hide any previously hovered cards (not the selected one)
            timelineEvents.forEach(otherEvent => {
              if (otherEvent !== event && otherEvent !== selectedEvent) {
                const otherCard = otherEvent.querySelector('.timeline-card');
                if (otherCard) {
                  otherCard.classList.add('opacity-0', 'pointer-events-none');
                }
                otherEvent.classList.remove('hovered');
              }
            });
            
            // Show this card
            card.classList.remove('opacity-0', 'pointer-events-none');
            event.classList.add('hovered');
          }
        });
        
        // Hide card when mouse leaves, unless it's the selected card
        event.addEventListener('mouseleave', () => {
          if (selectedEvent !== event) {
            card.classList.add('opacity-0', 'pointer-events-none');
            event.classList.remove('hovered');
          }
        });
      }
      
      // Add click listener to the star to handle selection
      starNode.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // If this event is already selected, navigate to the post
        if (selectedEvent === event) {
          window.location.href = event.getAttribute('href');
          return;
        }
        
        // Clear any other selected events
        if (selectedEvent) {
          selectedEvent.classList.remove('selected');
          const previousCard = selectedEvent.querySelector('.timeline-card');
          if (previousCard) {
            previousCard.classList.add('opacity-0', 'pointer-events-none');
          }
        }
        
        // Toggle selection state
        if (selectedEvent !== event) {
          // Select this event
          selectedEvent = event;
          event.classList.add('selected');
          card.classList.remove('opacity-0', 'pointer-events-none');
        } else {
          // Deselect if clicking the same one
          selectedEvent = null;
        }
      });
      
      // Add click listener to timeline background to handle deselection
      timelineEl.addEventListener('click', (e) => {
        // Only if clicking the timeline background (not a star or card)
        if (e.target === timelineEl || e.target.classList.contains('timeline-container')) {
          if (selectedEvent) {
            selectedEvent.classList.remove('selected');
            const selectedCard = selectedEvent.querySelector('.timeline-card');
            if (selectedCard) {
              selectedCard.classList.add('opacity-0', 'pointer-events-none');
            }
            selectedEvent = null;
          }
        }
      });
      
      // Add click listener to the card itself to prevent event propagation
      card.addEventListener('click', (e) => {
        e.stopPropagation();
      });
    });
    
    // Add touch event handling for mobile devices
    if ('ontouchstart' in window) {
      initTouchEvents(timelineEvents, (event) => {
        selectedEvent = event;
      });
    }
    
    // Add hover effects for connected events
    timelineEvents.forEach(event => {
      const era = event.getAttribute('data-era');
      if (!era) return;
      
      event.addEventListener('mouseenter', () => {
        // Highlight all events from the same era
        timelineEl.querySelectorAll(`.timeline-event[data-era="${era}"]`).forEach(relatedEvent => {
          if (relatedEvent !== event) {
            relatedEvent.classList.add('related-active');
          }
        });
      });
      
      event.addEventListener('mouseleave', () => {
        // Remove highlight from all events
        timelineEl.querySelectorAll('.related-active').forEach(el => {
          el.classList.remove('related-active');
        });
      });
    });
  }
  
  function initTouchEvents(timelineEvents, setSelectedCallback) {
    timelineEvents.forEach(event => {
      const starNode = event.querySelector('.star-node');
      const card = event.querySelector('.timeline-card');
      
      if (!starNode || !card) return;
      
      // Track touch state
      let touchStartTime = 0;
      let isSelected = false;
      
      // Add touch start handler
      starNode.addEventListener('touchstart', () => {
        touchStartTime = new Date().getTime();
      });
      
      // Add touch end handler
      starNode.addEventListener('touchend', (e) => {
        const touchEndTime = new Date().getTime();
        const touchDuration = touchEndTime - touchStartTime;
        
        // Prevent default behavior on tap
        e.preventDefault();
        
        if (isSelected) {
          // If already selected, navigate to the post
          window.location.href = event.getAttribute('href');
          return;
        }
        
        // Clear any other selected events
        timelineEvents.forEach(otherEvent => {
          if (otherEvent !== event) {
            otherEvent.classList.remove('selected');
            const otherCard = otherEvent.querySelector('.timeline-card');
            if (otherCard) {
              otherCard.classList.add('opacity-0', 'pointer-events-none');
            }
          }
        });
        
        // Select this event
        isSelected = true;
        event.classList.add('selected');
        card.classList.remove('opacity-0', 'pointer-events-none');
        
        // Call the callback to update the selected event
        if (typeof setSelectedCallback === 'function') {
          setSelectedCallback(event);
        }
      });
      
      // Add a way to deselect on touch outside
      document.addEventListener('touchstart', (e) => {
        if (isSelected && !event.contains(e.target)) {
          isSelected = false;
          event.classList.remove('selected');
          card.classList.add('opacity-0', 'pointer-events-none');
          
          // Call the callback to update the selected event
          if (typeof setSelectedCallback === 'function') {
            setSelectedCallback(null);
          }
        }
      });
    });
  }
</script>

<style>
  /* Add varying star sizes based on a pseudo-random pattern */
  .timeline-event:nth-child(3n+1) .star-icon {
    transform: scale(0.85);
  }
  
  .timeline-event:nth-child(7n+2) .star-icon {
    transform: scale(1.2);
  }
  
  .timeline-event:nth-child(5n+3) .star-icon {
    transform: scale(0.95);
  }
  
  .timeline-event:nth-child(11n+4) .star-icon {
    transform: scale(1.15);
  }
  
  /* Override the scale transformations in hover and selected states */
  .timeline-event:hover .star-icon,
  .timeline-event.selected .star-icon {
    transform: scale(1.25) !important;
  }
  
  /* Base star animation with varying timing */
  .star-icon {
    transform-origin: center;
    animation: starPulse 4s infinite alternate ease-in-out;
  }

  /* Create variable twinkle timing */
  .timeline-event:nth-child(3n) .star-icon {
    animation-duration: 3s;
  }

  .timeline-event:nth-child(3n+1) .star-icon {
    animation-duration: 5s;
  }

  .timeline-event:nth-child(3n+2) .star-icon {
    animation-duration: 4.5s;
  }
  
  /* Card positioning adjustments - now that we don't have connectors */
  .timeline-card {
    position: absolute;
    top: 20px; /* Position cards below stars by default */
    transition: opacity 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
    z-index: 30; /* Ensure cards are always on top when visible */
  }
  
  /* Make cards position smartly based on star position */
  .timeline-event[style*="top: calc(50% - 5"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 6"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 7"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 8"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 9"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 10"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 11"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 12"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 13"] .timeline-card,
  .timeline-event[style*="top: calc(50% - 14"] .timeline-card {
    top: -90px; /* Position cards above for stars in upper half */
  }
  
  /* Enhanced star glow effects */
  .star-icon.text-green-500 {
    filter: drop-shadow(0 0 4px rgba(34, 197, 94, 0.8));
  }

  .star-icon.text-yellow-500 {
    filter: drop-shadow(0 0 4px rgba(234, 179, 8, 0.8));
  }

  .star-icon.text-red-500 {
    filter: drop-shadow(0 0 4px rgba(239, 68, 68, 0.8));
  }

  .star-icon.text-indigo-500 {
    filter: drop-shadow(0 0 4px rgba(99, 102, 241, 0.8));
  }

  .star-icon.text-blue-500 {
    filter: drop-shadow(0 0 4px rgba(59, 130, 246, 0.8));
  }

  .star-icon.text-purple-500 {
    filter: drop-shadow(0 0 4px rgba(168, 85, 247, 0.8));
  }
  
  /* Ensure text cards have nice shadow */
  .timeline-card:not(.opacity-0) {
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.1), 0 0 5px rgba(var(--primary-rgb), 0.3);
  }
</style>