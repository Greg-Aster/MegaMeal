---
import Timeline from './Timeline.astro';
import { Icon } from 'astro-icon/components';
import { defaultEraDisplayNames, extractEraConfig, getTimelineEvents } from '../../services/TimelineService';
import TimelineNavigation from './TimelineNavigation.astro';
import '../../styles/timeline.css'; // Import consolidated CSS

interface Props {
  id?: string;
  title?: string;
  class?: string;
  category?: string;
  startYear?: number;
  endYear?: number;
  background?: string;
  compact?: boolean;
  asBanner?: boolean;
  bannerHeight?: string;
}

const {
  id = "timeline-controller",
  title = "Universe Timeline",
  class: className = "",
  category = "",
  startYear,
  endYear,
  background = "/assets/banner/0001.png",
  compact = false,
  asBanner = false,
  bannerHeight = "800px"
} = Astro.props;

// Get timeline events with our service, including banner posts
const timelineOptions = {
  category,
  startYear,
  endYear,
  includeBanners: true
};

const timelineEvents = await getTimelineEvents(timelineOptions);

// Extract era configuration from the timeline events
const eraConfig = extractEraConfig(timelineEvents);

// Determine actual display range based on events
let displayStartYear = startYear;
let displayEndYear = endYear;

if (timelineEvents.length > 0) {
  // If we have explicit years in props, use those
  if (startYear === undefined || endYear === undefined) {
    // Check for banner data with year range
    const bannerEvents = timelineEvents.filter(event => event.bannerData);
    if (bannerEvents.length > 0 && bannerEvents[0].bannerData) {
      if (displayStartYear === undefined && bannerEvents[0].bannerData.startYear) {
        displayStartYear = bannerEvents[0].bannerData.startYear;
      }
      if (displayEndYear === undefined && bannerEvents[0].bannerData.endYear) {
        displayEndYear = bannerEvents[0].bannerData.endYear;
      }
    }
    
    // If still undefined, calculate from events
    if (displayStartYear === undefined || displayEndYear === undefined) {
      const years = timelineEvents.map(event => event.year);
      const minYear = Math.min(...years);
      const maxYear = Math.max(...years);
      
      // Add padding for better visualization
      const padding = Math.max(5, Math.ceil((maxYear - minYear) * 0.1));
      
      if (displayStartYear === undefined) {
        displayStartYear = minYear - padding;
      }
      if (displayEndYear === undefined) {
        displayEndYear = maxYear + padding;
      }
    }
  }
}

// Get background from banner if available
let timelineBackground = background;
const bannerEvents = timelineEvents.filter(event => event.bannerData?.background);
if (bannerEvents.length > 0 && bannerEvents[0].bannerData?.background) {
  timelineBackground = bannerEvents[0].bannerData.background;
}

// Generate unique ID for this controller instance
const controllerId = `controller-${Math.random().toString(36).substring(2, 10)}`;
---

<div class={`flex flex-col w-full overflow-hidden relative ${asBanner ? 'timeline-banner-mode as-banner' : ''} ${className}`} 
     style={asBanner ? `height: 80vh;` : "height: 500px;"} 
     id={id} data-controller-id={controllerId}>
  <!-- Top control bar -->
  <div class="timeline-controls flex items-center justify-between p-1 bg-white/90 dark:bg-gray-800/90 border-b border-black/5 dark:border-white/5 z-10">
    <div class="flex items-center">
      <button id={`zoom-out-btn-${controllerId}`} class="flex items-center justify-center w-8 h-8 rounded-md mr-1 text-black/75 dark:text-white/75 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-[var(--primary)] transition-all" aria-label="Zoom out">
        <Icon name="material-symbols:zoom-out-map" class="text-xl" />
      </button>
      <button id={`zoom-in-btn-${controllerId}`} class="flex items-center justify-center w-8 h-8 rounded-md mr-3 text-black/75 dark:text-white/75 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-[var(--primary)] transition-all" aria-label="Zoom in">
        <Icon name="material-symbols:zoom-in-map" class="text-xl" />
      </button>
      
      <div class="h-5 border-r border-black/10 dark:border-white/10 mx-2"></div>
      
      <!-- Pan navigation buttons (2D) -->
      <div class="flex flex-col mr-2">
        <button id={`pan-up-btn-${controllerId}`} class="flex items-center justify-center w-8 h-8 rounded-md text-black/75 dark:text-white/75 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-[var(--primary)] transition-all" aria-label="Pan up">
          <Icon name="material-symbols:arrow-upward" class="text-xl" />
        </button>
        <button id={`pan-down-btn-${controllerId}`} class="flex items-center justify-center w-8 h-8 rounded-md text-black/75 dark:text-white/75 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-[var(--primary)] transition-all" aria-label="Pan down">
          <Icon name="material-symbols:arrow-downward" class="text-xl" />
        </button>
      </div>
      
      <div class="flex mr-2">
        <button id={`pan-left-btn-${controllerId}`} class="flex items-center justify-center w-8 h-8 rounded-md mr-1 text-black/75 dark:text-white/75 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-[var(--primary)] transition-all" aria-label="Pan left">
          <Icon name="material-symbols:arrow-back" class="text-xl" />
        </button>
        <button id={`pan-right-btn-${controllerId}`} class="flex items-center justify-center w-8 h-8 rounded-md text-black/75 dark:text-white/75 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-[var(--primary)] transition-all" aria-label="Pan right">
          <Icon name="material-symbols:arrow-forward" class="text-xl" />
        </button>
      </div>
      
      <div class="h-5 border-r border-black/10 dark:border-white/10 mx-2"></div>
      
      <div id={`era-filter-${controllerId}`} class="flex items-center">
        <span class="text-xs text-black/50 dark:text-white/50 mr-2">Era:</span>
        <select id={`era-select-${controllerId}`} class="bg-[var(--btn-regular-bg)] text-xs rounded-md p-1 text-[var(--btn-content)]">
          <option value="all">All Eras</option>
          <option value="all-time">All Time</option>
          {Object.entries(eraConfig).map(([value, config]) => (
            <option value={value}>{config.displayName}</option>
          ))}
        </select>
      </div>
      
      <div class="h-5 border-r border-black/10 dark:border-white/10 mx-2"></div>
      
      <!-- View type switcher -->
      <div id={`view-switcher-${controllerId}`} class="flex items-center">
        <span class="text-xs text-black/50 dark:text-white/50 mr-2">View:</span>
        <div class="timeline-view-switcher flex rounded-md overflow-hidden">
          <button 
            class="timeline-view-btn px-2 py-1 flex items-center text-xs bg-[var(--primary)] text-white"
            data-view="timeline"
          >
            <Icon name="material-symbols:view-timeline-outline" class="mr-1" />
            Timeline
          </button>
          <button 
            class="timeline-view-btn px-2 py-1 flex items-center text-xs bg-[var(--btn-regular-bg)] text-[var(--btn-content)]"
            data-view="list"
          >
            <Icon name="material-symbols:view-list" class="mr-1" />
            List
          </button>
          <button 
            class="timeline-view-btn px-2 py-1 flex items-center text-xs bg-[var(--btn-regular-bg)] text-[var(--btn-content)]"
            data-view="tree"
          >
            <Icon name="material-symbols:account-tree" class="mr-1" />
            Tree
          </button>
          <button 
            class="timeline-view-btn px-2 py-1 flex items-center text-xs bg-[var(--btn-regular-bg)] text-[var(--btn-content)]"
            data-view="map"
          >
            <Icon name="material-symbols:map" class="mr-1" />
            Map
          </button>
        </div>
      </div>
    </div>
    
    <div class="view-controls flex items-center">
      <button id={`compact-view-btn-${controllerId}`} class={`flex items-center justify-center w-8 h-8 rounded-md mr-1 transition-all ${compact ? 'text-[var(--primary)]' : 'text-black/75 dark:text-white/75'} hover:bg-gray-100 dark:hover:bg-gray-700`} aria-label="Compact view">
        <Icon name="material-symbols:view-compact-outline" class="text-xl" />
      </button>
      <button id={`expanded-view-btn-${controllerId}`} class={`flex items-center justify-center w-8 h-8 rounded-md transition-all ${!compact ? 'text-[var(--primary)]' : 'text-black/75 dark:text-white/75'} hover:bg-gray-100 dark:hover:bg-gray-700`} aria-label="Expanded view">
        <Icon name="material-symbols:view-timeline-outline" class="text-xl" />
      </button>
    </div>
  </div>
  
  <!-- Timeline viewport with overflow handling -->
  <div id={`timeline-viewport-${controllerId}`} 
       class="timeline-viewport relative flex-1 overflow-hidden cursor-grab active:cursor-grabbing" 
       style="min-height: calc(100% - 104px);">  <!-- 52px for each bar -->
    <div id={`timeline-wrapper-${controllerId}`} 
         class={`w-full h-full transition-all ${compact ? 'compact-mode' : 'expanded-mode'} square-timeline`}
         style="height: 100%;">
      <Timeline 
        category={category}
        startYear={displayStartYear}
        endYear={displayEndYear}
        background={timelineBackground}
        compact={compact}
        asBanner={asBanner}
        bannerHeight="100%"
      />
    </div>
    
    <!-- List View with scrollable content and bottom padding -->
    <div id={`list-view-${controllerId}`} class="timeline-view hidden pt-4 relative">
      <!-- Background image with overlay for list view -->
      <div class="absolute inset-0 -z-10 overflow-hidden">
        <img 
          src={timelineBackground} 
          alt="Timeline background" 
          class="w-full h-full object-cover opacity-25"
        />
        <div class="absolute inset-0 bg-gradient-to-r from-[oklch(0.35_0.05_var(--hue))] to-[oklch(0.25_0.05_var(--hue))] opacity-40 dark:opacity-30"></div>
      </div>
      
      <!-- Scrollable container for list view -->
      <div class="relative z-10 overflow-y-auto scrollbar-timeline" style="max-height: calc(100vh - 160px);">
        <div class="px-4">
          <TimelineNavigation 
            category={category}
            view="list"
            showCard={false}
            hideViewSwitcher={true}
          />
          <!-- Extra padding div to ensure content isn't obscured by footer when scrolled to bottom -->
          <div class="h-16"></div>
        </div>
      </div>
    </div>

    <!-- Tree View with scrollable content and bottom padding -->
    <div id={`tree-view-${controllerId}`} class="timeline-view hidden pt-4 relative">
      <!-- Background image with overlay for tree view -->
      <div class="absolute inset-0 -z-10 overflow-hidden">
        <img 
          src={timelineBackground} 
          alt="Timeline background" 
          class="w-full h-full object-cover opacity-25"
        />
        <div class="absolute inset-0 bg-gradient-to-r from-[oklch(0.35_0.05_var(--hue))] to-[oklch(0.25_0.05_var(--hue))] opacity-40 dark:opacity-30"></div>
      </div>
      
      <!-- Scrollable container for tree view -->
      <div class="relative z-10 overflow-y-auto scrollbar-timeline" style="max-height: calc(100vh - 160px);">
        <div class="px-4">
          <TimelineNavigation 
            category={category}
            view="tree"
            showCard={false}
            hideViewSwitcher={true}
          />
          <!-- Extra padding div to ensure content isn't obscured by footer when scrolled to bottom -->
          <div class="h-16"></div>
        </div>
      </div>
    </div>

    <!-- Map View with scrollable content -->
    <div id={`map-view-${controllerId}`} class="timeline-view hidden pt-4 relative">
      <!-- Background image with overlay for map view -->
      <div class="absolute inset-0 -z-10 overflow-hidden">
        <img 
          src={timelineBackground} 
          alt="Timeline background" 
          class="w-full h-full object-cover opacity-25"
        />
        <div class="absolute inset-0 bg-gradient-to-r from-[oklch(0.35_0.05_var(--hue))] to-[oklch(0.25_0.05_var(--hue))] opacity-40 dark:opacity-30"></div>
      </div>
      
      <!-- Scrollable container for map view -->
      <div class="relative z-10 overflow-y-auto scrollbar-timeline" style="max-height: calc(100vh - 160px);">
        <div class="px-4">
          <TimelineNavigation 
            category={category}
            view="map"
            showCard={false}
            hideViewSwitcher={true}
          />
          <!-- Extra padding div to ensure content isn't obscured by footer when scrolled to bottom -->
          <div class="h-16"></div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Bottom control bar with dynamic year display -->
  <div class="timeline-footer flex items-center justify-between p-1 bg-white/90 dark:bg-gray-800/90 border-t border-black/5 dark:border-white/5 z-10">
    <div class="flex items-center text-sm text-black/50 dark:text-white/50">
      <span id={`timeline-year-display-${controllerId}`} class="ml-2">
        Timeline: {displayStartYear || '—'} to {displayEndYear || '—'}
      </span>
    </div>
    
    <div class="flex items-center">
      <!-- Only Keep the Focus Events button -->
      <button id={`focus-events-btn-${controllerId}`} class="flex items-center justify-center px-3 py-1 rounded-md text-xs text-black/75 dark:text-white/75 hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-[var(--primary)] transition-all" aria-label="Focus on Events">
        <Icon name="material-symbols:center-focus-strong" class="text-sm mr-1" />
        Focus Events
      </button>
    </div>
  </div>
</div>

<script>
  // Define a global object to store controller functions
  window.timelineControllers = window.timelineControllers || {};
  
  // Function to initialize all controllers on the page
  function initAllTimelineControllers() {
    document.querySelectorAll('[data-controller-id]').forEach(controllerEl => {
      const controllerId = controllerEl.getAttribute('data-controller-id');
      if (!controllerId) return;
      
      setTimeout(() => {
        initTimelineController(controllerId);
      }, 100);
    });
  }
  
  // Initialize when DOM is ready and after page transitions
  document.addEventListener('DOMContentLoaded', initAllTimelineControllers);
  document.addEventListener('astro:page-load', initAllTimelineControllers);

  // Add Swup hooks if available
  if (window.swup?.hooks) {
    window.swup.hooks.on('content:replace', initAllTimelineControllers);
  }
  document.addEventListener('swup:enable', () => {
    if (window.swup?.hooks) {
      window.swup.hooks.on('content:replace', initAllTimelineControllers);
    }
  });
  
  // Main controller initialization function
  function initTimelineController(controllerId) {
    // Check if controller already initialized
    if (window.timelineControllers[controllerId]) {
      return;
    }
    
    // Create controller object
    const controller = {};
    
    // Store era configuration globally for this controller
    window.timelineEraConfig = {
      'pre-spork': {
        displayName: 'Pre-Spork Era',
        startYear: 0,
        endYear: 3042
      },
      'spork-uprising': {
        displayName: 'Spork Uprising',
        startYear: 3042,
        endYear: 3044
      },
      'snuggaloid': {
        displayName: 'Snuggaloid Emergence',
        startYear: 3044,
        endYear: 3050
      },
      'post-extinction': {
        displayName: 'Post-Extinction Recovery',
        startYear: 3050,
        endYear: 30000
      },
      'all-time': {
        displayName: 'All Time',
        startYear: 0,
        endYear: 30000
      }
    };
    
    // Store controller
    window.timelineControllers[controllerId] = controller;
    
    console.log(`Initializing timeline controller: ${controllerId}`);
    
    // Get DOM elements
    const controllerEl = document.querySelector(`[data-controller-id="${controllerId}"]`);
    const viewport = document.getElementById(`timeline-viewport-${controllerId}`);
    const wrapper = document.getElementById(`timeline-wrapper-${controllerId}`);
    const timelineContainer = wrapper?.querySelector('.timeline-container');
    
    if (!controllerEl || !viewport || !wrapper || !timelineContainer) {
      console.warn(`Missing elements for controller ${controllerId}`);
      return;
    }
    
    // Debug element selection
    console.log("Timeline container found:", !!timelineContainer, timelineContainer);
    if (!timelineContainer) {
      console.error("Timeline container not found in:", wrapper);
      return;
    }
    
    // Initialize state
    let scale = 100;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let startDragX = 0;
    let startDragY = 0;
    let startOffsetX = 0;
    let startOffsetY = 0;
    let lastUpdateTime = 0;
    
    // Zoom and pan functions - Enhanced for free navigation
    function zoomIn() {
      console.log('Zoom in');
      scale = Math.min(500, scale + 20); // Increased maximum zoom to 500%
      updateTransform();
    }
    
    function zoomOut() {
      console.log('Zoom out');
      const minScale = calculateMinScale();
      scale = Math.max(minScale, scale - 20);
      updateTransform();
    }
    
    function panLeft() {
      offsetX += 50; // Remove the scale check to allow panning at any zoom level
      updateTransform();
    }
    
    function panRight() {
      offsetX -= 50; // Remove the scale check to allow panning at any zoom level
      updateTransform();
    }
    
    function panUp() {
      offsetY += 30; // Remove the scale check to allow panning at any zoom level
      updateTransform();
    }
    
    function panDown() {
      offsetY -= 30; // Remove the scale check to allow panning at any zoom level
      updateTransform();
    }
    
    // Calculate minimum scale that fits viewport - Reduced for zooming out further
    function calculateMinScale() {
      return 50; // Changed from 100 to 50 to allow zooming out further
    }
    
    // Function to update the visible year range display
    function updateVisibleYearRange() {
      // Get the timeline element and its attributes
      const timeline = document.querySelector(`#timeline-wrapper-${controllerId} .timeline`);
      if (!timeline) return;
      
      // Get the base year range from the timeline
      const baseStartYear = parseInt(timeline.getAttribute('data-start-year') || '0');
      const baseEndYear = parseInt(timeline.getAttribute('data-end-year') || '0');
      if (!baseStartYear || !baseEndYear) return;
      
      // Calculate the full year span
      const yearSpan = baseEndYear - baseStartYear;
      
      // Calculate the visible year range based on current pan/zoom
      // This is an approximation based on the current transform
      const viewportWidth = viewport.offsetWidth;
      const containerWidth = timelineContainer.scrollWidth;
      const scaleFactor = scale / 100;
      
      // Calculate the viewport's visible portion as a percentage of the total width
      const visiblePortion = (viewportWidth / (containerWidth * scaleFactor));
      
      // Calculate visible year span
      const visibleYearSpan = yearSpan * visiblePortion;
      
      // Calculate center point offset as a percentage
      const centerOffset = offsetX / (containerWidth * scaleFactor / 2);
      
      // Calculate the visible year range center point
      const middleYear = baseStartYear + yearSpan / 2 - (yearSpan * centerOffset / 2);
      
      // Calculate visible start and end years
      const visibleStartYear = Math.round(middleYear - visibleYearSpan / 2);
      const visibleEndYear = Math.round(middleYear + visibleYearSpan / 2);
      
      // Update the display
      const yearDisplay = document.getElementById(`timeline-year-display-${controllerId}`);
      if (yearDisplay) {
        yearDisplay.textContent = `Visible: ${visibleStartYear} to ${visibleEndYear} (full range: ${baseStartYear} to ${baseEndYear})`;
      }
    }
    
    // Function to dynamically update the timeline content based on visible year range
    function updateTimelineContentForYearRange(startYear, endYear) {
      const timelineEvents = document.querySelectorAll('.timeline-event');
      
      // Only show events that fall within the specified year range
      timelineEvents.forEach(event => {
        const eventYear = parseInt(event.getAttribute('data-year') || '0');
        
        if (eventYear >= startYear && eventYear <= endYear) {
          // Event is within range - show it
          event.classList.remove('hidden-event');
          
          // Calculate position percentage within the new range
          const position = ((eventYear - startYear) / (endYear - startYear)) * 100;
          
          // Apply padding to prevent crowding at edges
          const PADDING_PERCENT = 15;
          const adjustedPosition = PADDING_PERCENT + 
            (position * (100 - (2 * PADDING_PERCENT)) / 100);
          
          // Update the event's position
          event.style.left = `${adjustedPosition}%`;
        } else {
          // Event is outside range - hide it
          event.classList.add('hidden-event');
        }
      });
    }
    
    // Function to smoothly transition to a new year range
    function transitionToYearRange(startYear, endYear, duration = 1000) {
      const timeline = document.querySelector(`#timeline-wrapper-${controllerId} .timeline`);
      if (!timeline) return;
      
      // Get current year range
      const currentStartYear = parseInt(timeline.getAttribute('data-visible-start-year') || 
                                      timeline.getAttribute('data-start-year') || '0');
      const currentEndYear = parseInt(timeline.getAttribute('data-visible-end-year') || 
                                    timeline.getAttribute('data-end-year') || '0');
      
      // Don't animate if there's no change
      if (currentStartYear === startYear && currentEndYear === endYear) return;
      
      // Setup animation
      const startTime = Date.now();
      
      function animateYearRange() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        
        // Use easing function for smoother transition
        const easeProgress = 1 - Math.pow(1 - progress, 3); // Cubic ease out
        
        // Calculate intermediate year values
        const intermediateStartYear = Math.round(
          currentStartYear + (startYear - currentStartYear) * easeProgress
        );
        const intermediateEndYear = Math.round(
          currentEndYear + (endYear - currentEndYear) * easeProgress
        );
        
        // Update the visible years
        timeline.setAttribute('data-visible-start-year', intermediateStartYear.toString());
        timeline.setAttribute('data-visible-end-year', intermediateEndYear.toString());
        
        // Update display
        const yearDisplay = document.getElementById(`timeline-year-display-${controllerId}`);
        if (yearDisplay) {
          yearDisplay.textContent = `Timeline: ${intermediateStartYear} to ${intermediateEndYear}`;
        }
        
        // Update visual positions of events
        updateTimelineContentForYearRange(intermediateStartYear, intermediateEndYear);
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateYearRange);
        }
      }
      
      // Start animation
      animateYearRange();
    }
    
    // Enhanced function to handle era selection
    function selectEra(era) {
      // First, reset and filter events by era
      filterByEra(era);
      
      // If era is "all", just reset to the default view
      if (era === 'all') {
        // Reset to original position - reusing code from "Focus Events" button
        scale = 100;
        offsetX = 0;
        offsetY = 0;
        updateTransform();
        return;
      }
      
      // Get era configuration for year ranges
      const eraConfig = window.timelineEraConfig || {};
      
      // If we have year range data for this era, adjust the visible range
      if (eraConfig[era]) {
        const eraStartYear = eraConfig[era].startYear;
        const eraEndYear = eraConfig[era].endYear;
        
        // Update the timeline element with the era-specific year range
        const timeline = document.querySelector(`#timeline-wrapper-${controllerId} .timeline`);
        if (timeline) {
          timeline.setAttribute('data-start-year', eraStartYear.toString());
          timeline.setAttribute('data-end-year', eraEndYear.toString());
          
          // Reset position and apply transform
          scale = 100;
          offsetX = 0;
          offsetY = 0;
          updateTransform();
          
          // Update the year display
          const yearDisplay = document.getElementById(`timeline-year-display-${controllerId}`);
          if (yearDisplay) {
            yearDisplay.textContent = `Timeline: ${eraStartYear} to ${eraEndYear} (Era: ${eraConfig[era].displayName})`;
          }
        }
      }
    }
    
    // Apply transforms with boundaries - optimized version with enhanced range
    function updateTransform() {
      // Remove any throttling for immediate response
      lastUpdateTime = Date.now();
      
      // If we're dragging, use the direct transform for instant response
      if (isDragging) {
        updateTransformDirect();
        return;
      }
      
      // Scale must never be smaller than minimum scale
      const minScale = Math.max(50, calculateMinScale()); // Reduced from 100 to allow zooming out further
      scale = Math.max(minScale, scale);
      
      // Calculate scale factor (1.0 = 100%)
      const scaleFactor = scale / 100;
      
      // Calculate container dimensions
      const containerWidth = timelineContainer.scrollWidth || 1000;
      const containerHeight = timelineContainer.scrollHeight || 500;
      const viewportWidth = viewport.offsetWidth || 800;
      const viewportHeight = viewport.offsetHeight || 400;
      
      // Calculate maximum offset - with increased limits for broader exploration
      // This is key to allowing wider navigation range - we've increased the multiplier from 1 to 3
      const maxOffsetX = Math.max(0, (containerWidth * scaleFactor * 3 - viewportWidth) / 2);
      const maxOffsetY = Math.max(0, (containerHeight * scaleFactor * 2 - viewportHeight) / 2);
      
      // We're no longer strictly limiting offsets to keep user able to pan anywhere
      // Instead, apply gentle resistance when moving far from center
      if (Math.abs(offsetX) > maxOffsetX) {
        // Apply resistance when panning beyond normal bounds - slow down but don't stop
        offsetX = offsetX > 0
          ? maxOffsetX + (offsetX - maxOffsetX) * 0.5
          : -maxOffsetX + (offsetX + maxOffsetX) * 0.5;
      }
      
      if (Math.abs(offsetY) > maxOffsetY) {
        // Apply resistance when panning beyond normal bounds - slow down but don't stop
        offsetY = offsetY > 0
          ? maxOffsetY + (offsetY - maxOffsetY) * 0.5
          : -maxOffsetY + (offsetY + maxOffsetY) * 0.5;
      }
      
      // Apply directly - no requestAnimationFrame for better responsiveness
      // Set the transform-origin to center for proper zooming
      timelineContainer.style.setProperty('transform-origin', 'center', 'important');
      timelineContainer.style.setProperty('width', '100%', 'important');
      timelineContainer.style.setProperty('height', '100%', 'important');
      
      // Apply transforms with scale AND translate for center-based zooming
      let transform = `scale(${scaleFactor})`;
      
      if (scale > 0) { // Changed from 100 to always apply translations
        // Add translations after scaling (always)
        transform += ` translateX(${offsetX / scaleFactor}px)`;
        transform += ` translateY(${offsetY / scaleFactor}px)`;
      }
      
      // Apply the combined transform
      timelineContainer.style.setProperty('transform', transform, 'important');
      timelineContainer.style.setProperty('will-change', 'transform', 'important');

      // Ensure overflow is visible
      timelineContainer.style.setProperty('min-width', 'auto', 'important');
      timelineContainer.style.setProperty('max-width', 'none', 'important');
      
      // Update background immediately after updating content
      updateBackgroundDirect(scaleFactor, offsetX, offsetY, maxOffsetX, maxOffsetY);
      
      // Update year range display
      updateVisibleYearRange();
    }
    
    // Similarly updated direct transform function for dragging
    function updateTransformDirect() {
      // Scale must never be smaller than minimum scale
      const minScale = Math.max(50, calculateMinScale()); // Reduced minimum scale
      scale = Math.max(minScale, scale);
      
      // Calculate scale factor (1.0 = 100%)
      const scaleFactor = scale / 100;
      
      // Calculate dimensions
      const containerWidth = timelineContainer.scrollWidth || 1000;
      const containerHeight = timelineContainer.scrollHeight || 500;
      const viewportWidth = viewport.offsetWidth || 800;
      const viewportHeight = viewport.offsetHeight || 400;
      
      // Calculate maximum offset with increased range for exploration
      const maxOffsetX = Math.max(0, (containerWidth * scaleFactor * 3 - viewportWidth) / 2);
      const maxOffsetY = Math.max(0, (containerHeight * scaleFactor * 2 - viewportHeight) / 2);
      
      // Apply resistance instead of strict limits
      if (Math.abs(offsetX) > maxOffsetX) {
        // Apply resistance when panning beyond normal bounds
        offsetX = offsetX > 0
          ? maxOffsetX + (offsetX - maxOffsetX) * 0.5
          : -maxOffsetX + (offsetX + maxOffsetX) * 0.5;
      }
      
      if (Math.abs(offsetY) > maxOffsetY) {
        // Apply resistance when panning beyond normal bounds
        offsetY = offsetY > 0
          ? maxOffsetY + (offsetY - maxOffsetY) * 0.5
          : -maxOffsetY + (offsetY + maxOffsetY) * 0.5;
      }
      
      // Direct transform application
      timelineContainer.style.transformOrigin = 'center';
      timelineContainer.style.width = '100%';
      timelineContainer.style.height = '100%';
      
      // Apply transforms - always include translations
      let transform = `scale(${scaleFactor})`;
      transform += ` translateX(${offsetX / scaleFactor}px)`;
      transform += ` translateY(${offsetY / scaleFactor}px)`;
      
      // Apply transform directly
      timelineContainer.style.transform = transform;
      timelineContainer.style.willChange = 'transform';
      
      // Ensure overflow is visible
      timelineContainer.style.minWidth = 'auto';
      timelineContainer.style.maxWidth = 'none';
      
      // Apply background transform directly
      updateBackgroundDirect(scaleFactor, offsetX, offsetY, maxOffsetX, maxOffsetY);
      
      // Update year range display
      updateVisibleYearRange();
    }
    
    // Direct background update for dragging - no delays - MODIFIED for fixed horizontal position
    function updateBackgroundDirect(scaleFactor, offsetX, offsetY, maxOffsetX, maxOffsetY) {
      // Find currently visible background
      let bgContainer = wrapper.querySelector('.timeline .absolute.inset-0');
      const imgElement = bgContainer?.querySelector('img');
      
      if (!imgElement) return;
      
      // Calculate background transform
      let bgTransform = '';
      
      // Scale background slightly larger than content
      const bgScaleFactor = Math.max(1.05, scaleFactor * 1.05);
      bgTransform = `scale(${bgScaleFactor})`;
      
      // IMPORTANT CHANGE: Only apply vertical movement to background
      // Ignore horizontal offsetX completely, keeping background fixed horizontally
      
      if (maxOffsetY > 0) {
        // Use same offset calculation as content for vertical movement only
        const followFactor = 1.25; // Lower = follows more closely
        const bgOffsetY = offsetY / (scaleFactor * followFactor);
        bgTransform += ` translateY(${bgOffsetY}px)`;
      }
      
      // Apply transform directly
      imgElement.style.transform = bgTransform;
      imgElement.style.willChange = 'transform';
    }
    
    // Set up event handlers
    function bindEvents() {
      // Button handlers
      const zoomInBtn = document.getElementById(`zoom-in-btn-${controllerId}`);
      const zoomOutBtn = document.getElementById(`zoom-out-btn-${controllerId}`);
      const panLeftBtn = document.getElementById(`pan-left-btn-${controllerId}`);
      const panRightBtn = document.getElementById(`pan-right-btn-${controllerId}`);
      const panUpBtn = document.getElementById(`pan-up-btn-${controllerId}`);
      const panDownBtn = document.getElementById(`pan-down-btn-${controllerId}`);
      const focusEventsBtn = document.getElementById(`focus-events-btn-${controllerId}`);
      
      if (zoomInBtn) zoomInBtn.addEventListener('click', (e) => {
        e.preventDefault();
        zoomIn();
      });
      
      if (zoomOutBtn) zoomOutBtn.addEventListener('click', (e) => {
        e.preventDefault();
        zoomOut();
      });
      
      if (panLeftBtn) panLeftBtn.addEventListener('click', (e) => {
        e.preventDefault();
        panLeft();
      });
      
      if (panRightBtn) panRightBtn.addEventListener('click', (e) => {
        e.preventDefault();
        panRight();
      });
      
      if (panUpBtn) panUpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        panUp();
      });
      
      if (panDownBtn) panDownBtn.addEventListener('click', (e) => {
        e.preventDefault();
        panDown();
      });
      
      // Enhanced Focus Events button to also reset the era filter
      if (focusEventsBtn) focusEventsBtn.addEventListener('click', (e) => {
        e.preventDefault();
        
        // Reset to initial position focusing on the events
        scale = 100;
        offsetX = 0;
        offsetY = 0;
        updateTransform();
        
        // Also reset the era filter
        const eraSelect = document.getElementById(`era-select-${controllerId}`);
        if (eraSelect) {
          eraSelect.value = 'all';
          filterByEra('all');
        }
      });
      
      // Dragging handlers
      viewport.addEventListener('mousedown', startDrag);
      window.addEventListener('mousemove', dragTimeline);
      window.addEventListener('mouseup', endDrag);
      
      // View mode handlers
      const compactBtn = document.getElementById(`compact-view-btn-${controllerId}`);
      const expandedBtn = document.getElementById(`expanded-view-btn-${controllerId}`);
      
      if (compactBtn) compactBtn.addEventListener('click', (e) => {
        e.preventDefault();
        wrapper.classList.add('compact-mode');
        wrapper.classList.remove('expanded-mode');
        compactBtn.classList.add('text-[var(--primary)]');
        if (expandedBtn) expandedBtn.classList.remove('text-[var(--primary)]');
        
        // Update after mode change
        setTimeout(updateTransform, 100);
      });
      
      if (expandedBtn) expandedBtn.addEventListener('click', (e) => {
        e.preventDefault();
        wrapper.classList.remove('compact-mode');
        wrapper.classList.add('expanded-mode');
        expandedBtn.classList.add('text-[var(--primary)]');
        if (compactBtn) compactBtn.classList.remove('text-[var(--primary)]');
        
        // Update after mode change
        setTimeout(updateTransform, 100);
      });
      
      // Era filter
      const eraSelect = document.getElementById(`era-select-${controllerId}`);
      if (eraSelect) {
        eraSelect.addEventListener('change', (e) => {
          selectEra(e.target.value);
        });
      }
      
      // View switcher
      initViewSwitcher();
      
      // Add scroll handlers
      initScrollHandlers();
      
      // Resize handler
      window.addEventListener('resize', updateTransform);
    }
    
    // Function to handle scrollable content
    function initScrollHandlers() {
      // Find all scrollable containers
      const scrollContainers = document.querySelectorAll('.scrollbar-timeline');
      
      scrollContainers.forEach(container => {
        // Add scroll event listener to each container
        container.addEventListener('scroll', function() {
          // Check if we're near the bottom
          const isAtBottom = this.scrollHeight - this.scrollTop - this.clientHeight < 30;
          
          // Add/remove class based on scroll position
          if (isAtBottom) {
            this.classList.add('at-bottom');
          } else {
            this.classList.remove('at-bottom');
          }
        });
      });
    }
    
    // Function to handle view switching
    function initViewSwitcher() {
      const viewButtons = document.querySelectorAll(`#view-switcher-${controllerId} .timeline-view-btn`);
      const timelineView = document.getElementById(`timeline-wrapper-${controllerId}`);
      const listView = document.getElementById(`list-view-${controllerId}`);
      const treeView = document.getElementById(`tree-view-${controllerId}`);
      const mapView = document.getElementById(`map-view-${controllerId}`);
      
      if (!viewButtons.length || !timelineView || !listView || !treeView || !mapView) {
        console.warn("Missing view elements");
        return;
      }
      
      viewButtons.forEach(button => {
        button.addEventListener('click', () => {
          // Get view type from data attribute
          const viewType = button.getAttribute('data-view') || "timeline";
          
          // Update button styles
          viewButtons.forEach(btn => {
            if (btn.getAttribute('data-view') === viewType) {
              btn.classList.add('bg-[var(--primary)]', 'text-white');
              btn.classList.remove('bg-[var(--btn-regular-bg)]', 'text-[var(--btn-content)]');
            } else {
              btn.classList.remove('bg-[var(--primary)]', 'text-white');
              btn.classList.add('bg-[var(--btn-regular-bg)]', 'text-[var(--btn-content)]');
            }
          });
          
          // Show/hide appropriate view
          timelineView.classList.toggle('hidden', viewType !== 'timeline');
          listView.classList.toggle('hidden', viewType !== 'list');
          treeView.classList.toggle('hidden', viewType !== 'tree');
          mapView.classList.toggle('hidden', viewType !== 'map');
          
          // Wait for the view to become visible
          setTimeout(initScrollHandlers, 200);
          
          // Save preference to localStorage
          localStorage.setItem(`timeline-view-${controllerId}`, viewType);
        });
      });
      
      // Load saved preference
      const savedView = localStorage.getItem(`timeline-view-${controllerId}`);
      if (savedView) {
        const targetButton = document.querySelector(`#view-switcher-${controllerId} .timeline-view-btn[data-view="${savedView}"]`);
        if (targetButton) {
          (targetButton as HTMLElement).click();
        }
      }
    }
    
    // Filter events by era across all views
    function filterByEra(era) {
      // Timeline events
      const timelineEvents = wrapper.querySelectorAll('.timeline-event');
      
      // Other view elements
      const listView = document.getElementById(`list-view-${controllerId}`);
      const treeView = document.getElementById(`tree-view-${controllerId}`);
      const mapView = document.getElementById(`map-view-${controllerId}`);
      
      // Get all the elements that can be filtered
      const listEvents = listView ? listView.querySelectorAll('.timeline-event-card') : [];
      const treeEvents = treeView ? treeView.querySelectorAll('.timeline-tree-node') : [];
      const mapEvents = mapView ? mapView.querySelectorAll('.location-card') : [];
      const mapPins = mapView ? mapView.querySelectorAll('.map-pin') : [];
      
      // Reset all events if "all" is selected
      if (era === 'all') {
        // Reset and show all events across all views
        [timelineEvents, listEvents, treeEvents, mapEvents, mapPins].forEach(elements => {
          elements.forEach(element => {
            element.style.opacity = '1';
            element.style.display = '';
            element.classList.remove('filtered-out');
          });
        });
        return;
      }
      
      // Apply filtering to each view
      
      // Filter timeline events
      applyFilter(timelineEvents, 'data-era', era);
      
      // Filter list view events
      applyFilter(listEvents, 'data-era', era);
      
      // Filter tree view events
      applyFilter(treeEvents, 'data-era', era);
      
      // Filter map view events and pins
      applyFilter(mapEvents, 'data-era', era);
      applyFilter(mapPins, 'data-era', era);
    }
    
    // Helper function to apply filtering consistently
    function applyFilter(elements, attributeName, targetValue) {
      elements.forEach(element => {
        const elementValue = element.getAttribute(attributeName);
        
        if (elementValue === targetValue) {
          // Element matches filter - show it prominently
          element.style.opacity = '1';
          element.style.display = '';
          element.classList.remove('filtered-out');
        } else {
          // Element doesn't match filter - grey it out
          element.style.opacity = '0.25';
          element.classList.add('filtered-out');
        }
      });
    }
    
    // Dragging functions with optimized instant movement - ENHANCED VERSION
    function startDrag(e) {
      // Allow dragging at any zoom level to enable full navigation
      isDragging = true;
      startDragX = e.clientX;
      startDragY = e.clientY;
      startOffsetX = offsetX;
      startOffsetY = offsetY;
      
      // Add dragging class to disable ALL transitions
      document.body.style.cursor = 'grabbing';
      viewport.classList.add('dragging');
      wrapper.querySelector('.timeline')?.classList.add('dragging');
      
      // Immediately apply transform changes for responsive feel
      updateTransformDirect();
      
      e.preventDefault();
    }
    
    function dragTimeline(e) {
      if (!isDragging) return;
      
      // Calculate new offsets
      const deltaX = e.clientX - startDragX;
      const deltaY = e.clientY - startDragY;
      
      // Get the current scale to determine how to handle dragging
      const zoomLevel = scale / 100;
      
      // Define a threshold for when we should use year range adjustment instead of physical movement
      // When zoomed out below this threshold, we'll adjust year range instead of position
      const YEAR_RANGE_DRAG_THRESHOLD = 0.8; // If scale is below 80%, use year range adjustment
      
      if (zoomLevel <= YEAR_RANGE_DRAG_THRESHOLD) {
        // YEAR RANGE ADJUSTMENT MODE
        // Add a visual indicator that we're in year range mode
        viewport.classList.add('year-range-mode');
        
        // Only move vertically (keep the parallax effect) but don't move horizontally
        offsetY = startOffsetY + deltaY;
        
        // Instead of moving horizontally, adjust the visible year range
        // Get the timeline element
        const timeline = document.querySelector(`#timeline-wrapper-${controllerId} .timeline`);
        if (timeline) {
          const baseStartYear = parseInt(timeline.getAttribute('data-start-year') || '0');
          const baseEndYear = parseInt(timeline.getAttribute('data-end-year') || '0');
          if (baseStartYear && baseEndYear) {
            // Calculate how much to adjust years based on drag distance
            // The sensitivity factor determines how many years per pixel of drag
            const yearSpan = baseEndYear - baseStartYear;
            const sensitivity = yearSpan / viewport.offsetWidth * 2; // Adjust this multiplier to control sensitivity
            
            // Calculate year adjustment based on drag distance
            const yearAdjustment = Math.round(deltaX * sensitivity);
            
            // Apply the adjustment to both start and end years to maintain the same range
            // We're shifting the window, not changing its size
            const tempStartYear = baseStartYear - yearAdjustment;
            const tempEndYear = baseEndYear - yearAdjustment;
            
            // Update the display immediately
            const yearDisplay = document.getElementById(`timeline-year-display-${controllerId}`);
            if (yearDisplay) {
              yearDisplay.textContent = `Timeline: ${tempStartYear} to ${tempEndYear}`;
              
              // Store these values so they can be used when rendering
              timeline.setAttribute('data-visible-start-year', tempStartYear.toString());
              timeline.setAttribute('data-visible-end-year', tempEndYear.toString());
            }
          }
        }
      } else {
        // NORMAL DRAG MODE - Move both horizontally and vertically as before
        viewport.classList.remove('year-range-mode');
        offsetX = startOffsetX + deltaX;
        offsetY = startOffsetY + deltaY;
      }
      
      // Apply the transform
      updateTransformDirect();
    }
    
    function endDrag() {
      if (!isDragging) return;
      
      isDragging = false;
      document.body.style.cursor = '';
      viewport.classList.remove('dragging');
      viewport.classList.remove('year-range-mode');
      wrapper.querySelector('.timeline')?.classList.remove('dragging');
      
      // Check if we were in year range adjustment mode
      const zoomLevel = scale / 100;
      const YEAR_RANGE_DRAG_THRESHOLD = 0.8;
      
      if (zoomLevel <= YEAR_RANGE_DRAG_THRESHOLD) {
        // Finalize the year range adjustment
        const timeline = document.querySelector(`#timeline-wrapper-${controllerId} .timeline`);
        if (timeline) {
          const visibleStartYear = parseInt(timeline.getAttribute('data-visible-start-year') || '0');
          const visibleEndYear = parseInt(timeline.getAttribute('data-visible-end-year') || '0');
          
          if (visibleStartYear && visibleEndYear) {
            // Update the main data attributes to match the visible range
            timeline.setAttribute('data-start-year', visibleStartYear.toString());
            timeline.setAttribute('data-end-year', visibleEndYear.toString());
            
            // Clear the temporary visible attributes
            timeline.removeAttribute('data-visible-start-year');
            timeline.removeAttribute('data-visible-end-year');
            
            // Update the display
            const yearDisplay = document.getElementById(`timeline-year-display-${controllerId}`);
            if (yearDisplay) {
              yearDisplay.textContent = `Timeline: ${visibleStartYear} to ${visibleEndYear}`;
            }
            
            // Ensure events are properly positioned and visible
            updateTimelineContentForYearRange(visibleStartYear, visibleEndYear);
          }
        }
      }
    }
    
    // Initialize the controller
    bindEvents();
    
    // Allow for complete DOM rendering before first transform
    setTimeout(() => {
      console.log("Initial transform application");
      updateTransform();
      
      // Apply a second update after a short delay to ensure it takes effect
      setTimeout(updateTransform, 200);
    }, 100);
  }
</script>