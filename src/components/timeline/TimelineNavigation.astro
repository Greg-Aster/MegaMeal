---
// components/timeline/TimelineNavigation.astro
import { Icon } from 'astro-icon/components';
import { getTimelineEvents, groupEventsByEra, getEraDisplayName, getEraClasses } from '../../services/TimelineService';
import { getPostUrlBySlug } from '../../utils/url-utils';
import '../../styles/timeline.css'; // Add this import


interface Props {
  class?: string;
  category?: string;         // Optional category filter
  view?: 'list' | 'tree' | 'map';
  showCard?: boolean;        // New prop to control card-base styling
  hideViewSwitcher?: boolean; // New prop to hide the view switcher
}

const { 
  class: className = "",
  category = "",
  view = "list",
  showCard = true,
  hideViewSwitcher = false
} = Astro.props;

// Get timeline events with our service
const timelineEvents = await getTimelineEvents({
  category
});

// Group events by era
const eventsByEra = groupEventsByEra(timelineEvents);

// Generate unique ID for this component instance
const navigationId = `nav-${Math.random().toString(36).substring(2, 10)}`;
---

<timeline-navigation 
  id={navigationId} 
  data-view={view} 
  class={`timeline-navigation ${showCard ? 'card-base p-4' : ''} ${className}`}
>
  <!-- View switcher - only shown if hideViewSwitcher is false -->
  {!hideViewSwitcher && (
    <div class="flex justify-end mb-4">
      <div class="timeline-view-switcher flex rounded-md overflow-hidden">
        <button 
          class={`timeline-view-btn px-3 py-1 flex items-center text-sm ${view === 'list' ? 'bg-[var(--primary)] text-white' : 'bg-[var(--btn-regular-bg)] text-[var(--btn-content)]'}`}
          data-view="list"
        >
          <Icon name="material-symbols:view-list" class="mr-1" />
          List
        </button>
        <button 
          class={`timeline-view-btn px-3 py-1 flex items-center text-sm ${view === 'tree' ? 'bg-[var(--primary)] text-white' : 'bg-[var(--btn-regular-bg)] text-[var(--btn-content)]'}`}
          data-view="tree"
        >
          <Icon name="material-symbols:account-tree" class="mr-1" />
          Tree
        </button>
        <button 
          class={`timeline-view-btn px-3 py-1 flex items-center text-sm ${view === 'map' ? 'bg-[var(--primary)] text-white' : 'bg-[var(--btn-regular-bg)] text-[var(--btn-content)]'}`}
          data-view="map"
        >
          <Icon name="material-symbols:map" class="mr-1" />
          Map
        </button>
      </div>
    </div>
  )}
  
  <!-- List View -->
  <div id={`list-view-${navigationId}`} class={`timeline-view ${view !== 'list' ? 'hidden' : ''}`}>
    {Object.entries(eventsByEra).map(([era, events]) => (
      <div class="timeline-era mb-6">
        <div class={`era-header px-3 py-2 rounded-md mb-2 font-bold ${getEraClasses(era)}`}>
          {getEraDisplayName(era)} ({events[0].year} - {events[events.length - 1].year})
        </div>
        <div class="era-events">
          {events.map((event) => (
            <a href={getPostUrlBySlug(event.slug)} class="timeline-event-card flex hover:bg-[var(--btn-card-bg-hover)] rounded-md p-2 mb-2 transition-colors" data-era={event.era}>
              <div class="event-year w-16 font-bold text-center text-[var(--primary)]">
                {event.year}
              </div>
              <div class="event-connector w-8 flex items-center justify-center relative">
                <div class="h-full w-0.5 bg-[var(--primary)] opacity-30"></div>
                <div class={`w-3 h-3 rounded-full absolute ${event.isKeyEvent ? 'bg-[var(--primary)]' : 'border-2 border-[var(--primary)] bg-[var(--card-bg)]'}`}></div>
              </div>
              <div class="event-content flex-1">
                <div class="event-title font-bold text-75">{event.title}</div>
                <div class="event-description text-50 text-sm">{event.description}</div>
                {event.location && (
                  <div class="event-location text-xs mt-1 text-[var(--primary)]">
                    <Icon name="material-symbols:location-on" class="inline-block h-3 w-3 mr-1" />
                    {event.location}
                  </div>
                )}
              </div>
              {/* Keep data attribute for filtering, but don't show the key event badge */}
              <div class="hidden" data-is-key-event={event.isKeyEvent ? "true" : "false"}></div>
              {/* Keep data-era for filtering, but render as a hidden element */}
              {event.era && (
                <div class="hidden" data-era={event.era}></div>
              )}
            </a>
          ))}
        </div>
      </div>
    ))}
  </div>
  
  <!-- Tree View -->
  <div id={`tree-view-${navigationId}`} class={`timeline-view ${view !== 'tree' ? 'hidden' : ''}`}>
    <div class="timeline-tree pl-8 relative">
      <!-- Main vertical line -->
      <div class="absolute left-4 top-0 bottom-0 w-0.5 bg-[var(--primary)] opacity-30"></div>
      
      {timelineEvents.map((event) => (
        <a href={getPostUrlBySlug(event.slug)} class="timeline-tree-node flex relative hover:bg-[var(--btn-card-bg-hover)] rounded-md p-2 mb-4 transition-colors" data-era={event.era}>
          <!-- Circle on the line -->
          <div class="absolute left-4 top-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <div class={`tree-node-circle ${event.isKeyEvent ? 'w-5 h-5 bg-[var(--primary)]' : 'w-4 h-4 border-2 border-[var(--primary)] bg-[var(--card-bg)]'} rounded-full`}></div>
          </div>
          
          <!-- Horizontal connector -->
          <div class="h-0.5 w-8 bg-[var(--primary)] opacity-30 absolute left-4 top-1/2 transform"></div>
          
          <!-- Event content -->
          <div class="pl-8 pt-2 pb-2">
            <div class="flex items-center mb-1">
              <span class="text-[var(--primary)] font-bold mr-2">{event.year}</span>
              <span class={`text-xs py-0.5 px-2 rounded-full ${getEraClasses(event.era || 'unknown')}`} data-era={event.era}>
                {getEraDisplayName(event.era || 'unknown')}
              </span>
              {event.isKeyEvent && (
                <span class="ml-2 text-xs font-bold py-0.5 px-2 rounded-full bg-[var(--primary)] text-white">Key Event</span>
              )}
            </div>
            <div class="event-title font-bold text-75 mb-1">{event.title}</div>
            <div class="event-description text-50 text-sm">{event.description}</div>
            {event.location && (
              <div class="event-location text-xs mt-1 text-[var(--primary)]">
                <Icon name="material-symbols:location-on" class="inline-block h-3 w-3 mr-1" />
                {event.location}
              </div>
            )}
          </div>
        </a>
      ))}
    </div>
  </div>
  
<!-- Map View (interactive visualization of locations) with fixed height -->
<div id={`map-view-${navigationId}`} class={`timeline-view ${view !== 'map' ? 'hidden' : ''}`}>
  <div class="map-container relative bg-[oklch(0.95_0.03_var(--hue))]/80 dark:bg-[oklch(0.2_0.03_var(--hue))]/80 backdrop-blur-sm rounded-md overflow-hidden" style="height: calc(70vh - 140px); min-height: 300px;">
    <!-- More opaque map visualization -->
    <div class="absolute inset-0 opacity-75">
      <svg viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg" class="w-full h-full">
        <!-- Simple map grid background -->
        <defs>
          <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
            <path d="M 40 0 L 0 0 0 40" fill="none" stroke="currentColor" stroke-width="0.8" />
          </pattern>
        </defs>
        <rect width="100%" height="100%" fill="url(#grid)" class="text-[var(--primary)]" />
        
        <!-- Simplified "continents" with increased opacity -->
        <path d="M 80,50 C 100,40 150,30 200,50 C 250,70 280,90 300,70 C 320,50 350,60 350,80 C 350,100 320,120 300,150 C 280,180 250,190 200,180 C 150,170 120,190 100,170 C 80,150 60,130 80,100 C 100,70 80,50 80,50 Z" 
              fill="oklch(0.7 0.1 var(--hue))" fill-opacity="0.7" stroke="oklch(0.5 0.2 var(--hue))" stroke-width="1.5" />
        
        <path d="M 30,200 C 40,180 70,170 100,190 C 130,210 160,200 170,220 C 180,240 150,260 120,250 C 90,240 60,250 50,230 C 40,210 30,200 30,200 Z"
              fill="oklch(0.6 0.15 var(--hue))" fill-opacity="0.7" stroke="oklch(0.5 0.2 var(--hue))" stroke-width="1.5" />
              
        <!-- Place dots for events with locations - made more prominent -->
        {timelineEvents
          .filter(event => event.location)
          .map((event) => {
            // Simple algorithm to distribute points on the map based on location name
            // In a real implementation, you'd have actual coordinates
            const hash = event.location ? [...event.location].reduce((h, c) => (h * 31 + c.charCodeAt(0)) % 360, 0) : 0;
            const x = 50 + (hash % 300);
            const y = 50 + ((hash * 17) % 200);
            return (
              <g class="map-pin" data-event-slug={event.slug} data-event-year={event.year} data-era={event.era}>
                <circle cx={x} cy={y} r={event.isKeyEvent ? 10 : 6} 
                  fill={event.isKeyEvent ? "oklch(0.8 0.2 var(--hue))" : "oklch(0.6 0.1 var(--hue))"}
                  stroke="white" stroke-width="2" />
                <text x={x} y={y + 20} text-anchor="middle" font-weight="bold" fill="currentColor" font-size="11">{event.year}</text>
              </g>
            );
          })
        }
      </svg>
    </div>
    
    <!-- Map overlay instructions - more visible -->
    <div class="absolute top-4 right-4 bg-[oklch(0.9_0.03_var(--hue))]/90 dark:bg-[oklch(0.2_0.05_var(--hue))]/90 p-3 rounded-md text-sm text-75 backdrop-blur-sm shadow-md">
      <div class="font-bold mb-2">Map Legend</div>
      <div class="flex items-center mb-2">
        <div class="w-4 h-4 rounded-full bg-[oklch(0.6_0.1_var(--hue))] mr-2"></div>
        <span>Regular Event</span>
      </div>
      <div class="flex items-center">
        <div class="w-5 h-5 rounded-full bg-[oklch(0.8_0.2_var(--hue))] mr-1"></div>
        <span>Key Event</span>
      </div>
    </div>
    
    <!-- Empty state message if no locations -->
    {!timelineEvents.some(event => event.location) && (
      <div class="absolute inset-0 flex items-center justify-center">
        <div class="text-center p-8 bg-[oklch(0.95_0.03_var(--hue))]/80 dark:bg-[oklch(0.2_0.03_var(--hue))]/80 backdrop-blur-sm rounded-xl shadow-lg">
          <Icon name="material-symbols:map" class="text-5xl text-[var(--primary)] mb-3" />
          <p class="text-75 font-bold text-lg">No Location Data Available</p>
          <p class="text-50 mt-2">Add timelineLocation to your posts to place events on this map.</p>
        </div>
      </div>
    )}
  </div>
  
  <!-- Timeline events that have locations listed below the map -->
  <div class="timeline-map-events mt-4">
    <h3 class="font-bold text-75 mb-2">Timeline Locations</h3>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
      {timelineEvents.filter(event => event.location).map(event => (
        <a href={getPostUrlBySlug(event.slug)} class="location-card flex items-center p-2 hover:bg-[var(--btn-card-bg-hover)] rounded-md transition-colors" data-era={event.era}>
          <div class="location-icon mr-2 text-[var(--primary)]">
            <Icon name="material-symbols:location-on" class="h-5 w-5" />
          </div>
          <div class="location-info">
            <div class="font-bold text-75 text-sm">{event.title} ({event.year})</div>
            <div class="text-50 text-xs">{event.location}</div>
          </div>
        </a>
      ))}
    </div>
  </div>
</div>
</timeline-navigation>

<script>
class TimelineNavigation extends HTMLElement {
  constructor() {
    super();
    
    // Initialize after the DOM is fully loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        this.init();
      });
    } else {
      this.init();
    }
  }
  
  init() {
    // Only initialize once
    if (this.hasAttribute('data-initialized')) return;
    this.setAttribute('data-initialized', 'true');
    
    this.initViewSwitcher();
    this.initMapInteractions();
    this.initTreeNodes();
  }
  
  initViewSwitcher() {
    const viewButtons = this.querySelectorAll('.timeline-view-btn');
    const views = this.querySelectorAll('.timeline-view');
    const navigationId = this.id;
    
    viewButtons.forEach(button => {
      button.addEventListener('click', () => {
        // Get view type from data attribute
        const viewType = button.getAttribute('data-view') || "list";
        
        // Update button state
        viewButtons.forEach(btn => {
          if (btn.getAttribute('data-view') === viewType) {
            btn.classList.add('bg-[var(--primary)]', 'text-white');
            btn.classList.remove('bg-[var(--btn-regular-bg)]', 'text-[var(--btn-content)]');
          } else {
            btn.classList.remove('bg-[var(--primary)]', 'text-white');
            btn.classList.add('bg-[var(--btn-regular-bg)]', 'text-[var(--btn-content)]');
          }
        });
        
        // Show selected view, hide others
        views.forEach(view => {
          if (view.id === `${viewType}-view-${navigationId}`) {
            view.classList.remove('hidden');
          } else {
            view.classList.add('hidden');
          }
        });
        
        // Update data attribute for state tracking
        this.setAttribute('data-view', viewType);
        
        // Save preference
        localStorage.setItem('timeline-view-preference', viewType);
      });
    });
    
    // Load saved preference
    const savedView = localStorage.getItem('timeline-view-preference');
    if (savedView) {
      const targetButton = this.querySelector(`.timeline-view-btn[data-view="${savedView}"]`);
      if (targetButton) {
        (targetButton as HTMLElement).click();
      }
    }
  }
  
  initMapInteractions() {
    // Add hover effects to map pins
    const mapPins = this.querySelectorAll('.map-pin');
    const locationCards = this.querySelectorAll('.location-card');
    
    mapPins.forEach(pin => {
      const slug = pin.getAttribute('data-event-slug');
      
      // Highlight related location card when hovering over a map pin
      pin.addEventListener('mouseenter', () => {
        // Make the pin larger
        const circle = pin.querySelector('circle');
        if (circle) {
          const originalRadius = circle.getAttribute('r');
          circle.setAttribute('data-original-radius', originalRadius || '5');
          circle.setAttribute('r', parseFloat(originalRadius || '5') * 1.5 + '');
        }
        
        // Find and highlight matching location card
        locationCards.forEach(card => {
          const href = card.getAttribute('href');
          if (href && slug && href.includes(slug)) {
            card.classList.add('bg-[var(--btn-card-bg-hover)]');
          }
        });
      });
      
      pin.addEventListener('mouseleave', () => {
        // Reset pin to original size
        const circle = pin.querySelector('circle');
        if (circle) {
          const originalRadius = circle.getAttribute('data-original-radius');
          if (originalRadius) {
            circle.setAttribute('r', originalRadius);
          }
        }
        
        // Remove highlighting from location cards
        locationCards.forEach(card => {
          card.classList.remove('bg-[var(--btn-card-bg-hover)]');
        });
      });
      
      // Make the pins clickable
      pin.addEventListener('click', () => {
        const slug = pin.getAttribute('data-event-slug');
        if (slug) {
          window.location.href = `/posts/${slug}/`;
        }
      });
    });
  }
  
  initTreeNodes() {
    // Add animation effects for tree view nodes
    const treeNodes = this.querySelectorAll('.timeline-tree-node');
    
    treeNodes.forEach((node, index) => {
      // Add delayed entrance animation
      setTimeout(() => {
        node.classList.add('tree-node-visible');
      }, index * 50);
      
      // Connect related events by era
      node.addEventListener('mouseenter', () => {
        const eraElement = node.querySelector('.rounded-full');
        const era = eraElement ? eraElement.textContent?.trim() : null;
        if (!era) return;
        
        treeNodes.forEach(otherNode => {
          const otherEraElement = otherNode.querySelector('.rounded-full');
          const otherEra = otherEraElement ? otherEraElement.textContent?.trim() : null;
          if (otherNode !== node && otherEra === era) {
            otherNode.classList.add('related-node');
          }
        });
      });
      
      node.addEventListener('mouseleave', () => {
        treeNodes.forEach(otherNode => {
          otherNode.classList.remove('related-node');
        });
      });
    });
  }
}

// Register the custom element
customElements.define('timeline-navigation', TimelineNavigation);

// Initialize on Astro page transitions
document.addEventListener('astro:page-load', () => {
  document.querySelectorAll('timeline-navigation').forEach(component => {
    if (component instanceof TimelineNavigation) {
      component.init();
    }
  });
});
</script>
